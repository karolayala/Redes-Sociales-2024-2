[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "",
    "section": "",
    "text": "Materia: Redes sociales\nEstudiante: Karol Stefanny Ayala López\nSemestre: 2024-2"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Taller 2",
    "section": "",
    "text": "library(\"igraph\"); library(\"here\");library(\"rstudioapi\")\n\n\nAdjuntando el paquete: 'igraph'\n\n\nThe following objects are masked from 'package:stats':\n\n    decompose, spectrum\n\n\nThe following object is masked from 'package:base':\n\n    union\n\n\nhere() starts at C:/Users/Lenovo/Documents/UNAL/Materias/RedesSociales/Redes Sociales 2024-2\n\nsetwd(here())\ndirectorio &lt;- getwd()",
    "crumbs": [
      "Talleres",
      "Taller 2"
    ]
  },
  {
    "objectID": "inicio.html",
    "href": "inicio.html",
    "title": "Redes Sociales",
    "section": "",
    "text": "Karol Ayala"
  },
  {
    "objectID": "about.html#punto-2",
    "href": "about.html#punto-2",
    "title": "Taller 2",
    "section": "Punto 2",
    "text": "Punto 2\nTanto para redes dirigidas como no dirigidas, se define la media global de las interacciones como \\[\n\\bar{y}=\\frac{1}{n(n-1)}\\sum_{i,j:i\\neq j} y_{i,j}\n\\] donde \\(\\mathbf{Y}=[y_{i,j}]\\) es la matriz de adyacencia de la red correspondiente. Tal estadístico corresponde a una descripción muy rudimentaria acerca de la plausibilidad de observar una relación entre dos nodos cualesquiera, dado que no tiene en cuenta la heterogeneidad nodal (algunos nodos son más propensos a enviar/recibir más relaciones).\na. Muestre que para relaciones no dirigidas la media global \\(\\bar{y}\\) es igual a la media tanto de la parte triangular superior de \\(\\mathbf{Y}\\) como de la parte triangular inferior de \\(\\mathbf{Y}\\).\nb. Muestre que tanto para relaciones dirigidas como no dirigidas la media global corresponde a la densidad de la red.\nc. Muestre que tanto para relaciones dirigidas como no dirigidas se tiene que \\((n-1)\\bar{y} = \\bar{d}^{\\text{out}}=\\bar{d}^{\\text{in}}\\). Es decir, el grado promedio tanto de entrada como de salida son iguales y a su vez equivalentes la densidad.",
    "crumbs": [
      "Talleres",
      "Taller 2"
    ]
  },
  {
    "objectID": "about.html#punto-3",
    "href": "about.html#punto-3",
    "title": "Taller 2",
    "section": "Punto 3",
    "text": "Punto 3\nConsidere un grafo estrella de orden \\(n\\) y un grafo círculo de orden \\(n\\). A continuación se representan ambos grafos para \\(n=9\\). Estos grafos tienen aproximadamente la misma densidad, pero su estructura es muy diferente. Recuerde que la densidad de un grafo se puede calcular como el grado promedio dividido por \\(n - 1\\).\na. Muestre que para el grafo círculo de orden \\(n\\) el grado promedio es \\(\\bar{d} = 2\\).\nb. Muestre que para el grafo estrella de orden \\(n\\) el grado promedio es \\(\\bar{d} = 2\\frac{n-1}{n} \\rightarrow 2\\) cuando \\(n\\rightarrow\\infty\\).",
    "crumbs": [
      "Talleres",
      "Taller 2"
    ]
  },
  {
    "objectID": "about.html#punto-1",
    "href": "about.html#punto-1",
    "title": "Taller 2",
    "section": "Punto 1",
    "text": "Punto 1\nEl grado de un nodo en una red tanto dirigida como no dirigida se puede calcular fácilmente a partir de la matriz de adyacencia \\(\\mathbf{Y}=[y_{i,j}]\\). El out-degree \\(d_i^{\\text{out}}\\) y el in-degree \\(d_i^{\\text{in}}\\) del nodo \\(i\\) se pueden calcular respectivamente como: \\[\nd_i^{\\text{out}} = \\sum_{j:j\\neq i} y_{i,j}\n\\qquad\\text{y}\\qquad\nd_i^{\\text{in}} = \\sum_{j:j\\neq i} y_{j,i}\n\\] Muestre que este cálculo funciona tanto para relaciones dirigidas como no dirigidas. Específicamente, muestre que si la red es no dirigida entonces \\(d_i^{\\text{out}} = d_i^{\\text{in}}\\).",
    "crumbs": [
      "Talleres",
      "Taller 2"
    ]
  },
  {
    "objectID": "about.html#punto-4",
    "href": "about.html#punto-4",
    "title": "Taller 2",
    "section": "Punto 4",
    "text": "Punto 4\n¿Cuáles de las siguientes secuencias son caminatas en el grafo que se presenta a continuación? ¿Cuáles senderos? ¿Cuáles circuitos? ¿Cuáles ciclos?\na. \\(2 - 1 - 6 - 3 - 4\\).\nb. \\(2 - 1 - 6 - 3 - 4 - 1 - 5\\).\nc. \\(2 - 1 - 2 - 5 - 1 - 4\\).",
    "crumbs": [
      "Talleres",
      "Taller 2"
    ]
  },
  {
    "objectID": "about.html#punto-5",
    "href": "about.html#punto-5",
    "title": "Taller 2",
    "section": "Punto 5",
    "text": "Punto 5\nConsidere el conjunto de datos dado en comtrade.RData (este archivo contiene una arreglo de cuatro dimensiones denominado comtrade), asociado con el crecimiento anual del comercio (diferencia en dólares en escala logarítmica respecto al año 2000). Este conjunto de datos involucra 30 países, 10 años desde 1996 hasta 2005, y 6 clases de productos diferentes, como se muestra a continuación:\n\nload(\"comtrade.RData\")\ndimnames(comtrade)[c(1,3,4)]\n\n[[1]]\n [1] \"Australia\"            \"Austria\"              \"Brazil\"              \n [4] \"Canada\"               \"China\"                \"China, Hong Kong SAR\"\n [7] \"Czech Rep.\"           \"Denmark\"              \"Finland\"             \n[10] \"France\"               \"Germany\"              \"Greece\"              \n[13] \"Indonesia\"            \"Ireland\"              \"Italy\"               \n[16] \"Japan\"                \"Malaysia\"             \"Mexico\"              \n[19] \"Netherlands\"          \"New Zealand\"          \"Norway\"              \n[22] \"Rep. of Korea\"        \"Singapore\"            \"Spain\"               \n[25] \"Sweden\"               \"Switzerland\"          \"Thailand\"            \n[28] \"Turkey\"               \"United Kingdom\"       \"USA\"                 \n\n[[2]]\n[1] \"Chemicals\"                                    \n[2] \"Crude materials, inedible, except fuels\"      \n[3] \"Food and live animals\"                        \n[4] \"Machinery and transport equipment\"            \n[5] \"Manufact goods classified chiefly by material\"\n[6] \"Miscellaneous manufactured articles\"          \n\n[[3]]\n [1] \"1996\" \"1997\" \"1998\" \"1999\" \"2000\" \"2001\" \"2002\" \"2003\" \"2004\" \"2005\"\n\n\na. Calcule el aumento medio global \\(\\bar{y}\\) a lo largo de los 10 años en bienes manufacturados. Para ello considere la matriz de adyacencia Y dada por:\n\n# Y &lt;- apply(X = comtrade[,,c(5,6),], MARGIN = c(1,2), FUN = mean)\n# dim(Y)\n# round(Y[1:5,1:5], 2)\n\nb. Calcule la media de todas las observaciones de cada fila de Y, es decir, calcule la media fila \\(\\bar{y}_{i\\bullet}=\\frac{1}{n-1}\\sum_{j:j\\neq i} y_{i,j}\\) para cada país. Realice una histograma de los promedios fila \\(\\bar{y}_{i\\bullet}\\). Los promedios fila caracterizan diferentes niveles de actividad de los nodos en términos de la sociabilidad. ¿Cómo se pueden interpretar los promedios fila \\(\\bar{y}_{i\\bullet}\\)?\nc. Calcule la media de todas las observaciones de cada columna de Y, es decir, calcule la media columna \\(\\bar{y}_{\\bullet j}=\\frac{1}{n-1}\\sum_{i:i\\neq j} y_{i,j}\\) para cada país. Realice una histograma de los promedios columna \\(\\bar{y}_{\\bullet j}\\). Los promedios columna caracterizan diferentes niveles de actividad de los nodos en términos de la popularidad. ¿Cómo se pueden interpretar los promedio columna \\(\\bar{y}_{\\bullet j}\\)?\nd. Calcule tanto la media de los promedios fila \\(\\bar{y}_{i\\bullet}\\) como la media de los promedios columna \\(\\bar{y}_{\\bullet j}\\).\ne. Calcule tanto la DE de los promedios fila \\(\\bar{y}_{i\\bullet}\\) como la DE de los promedios columna \\(\\bar{y}_{\\bullet j}\\). ¿Qué se puede concluir acerca de la heterogeneidad local en este caso?\nf. Calcule el coeficiente de correlación entre los promedios fila \\(\\bar{y}_{i\\bullet}\\) y los promedios columna \\(\\bar{y}_{\\bullet j}\\). Realice un dispersograma de los promedios columna \\(\\bar{y}_{\\bullet j}\\) (eje \\(y\\)) frente a los promedios fila \\(\\bar{y}_{i\\bullet}\\) (eje \\(x\\)), junto con la recta \\(y=x\\) como punto de referencia. ¿Qué se puede concluir?",
    "crumbs": [
      "Talleres",
      "Taller 2"
    ]
  },
  {
    "objectID": "about.html#punto-6",
    "href": "about.html#punto-6",
    "title": "Taller 2",
    "section": "Punto 6",
    "text": "Punto 6\nConsidere el conjunto de datos dado en conflict.RData recopilado por Mike Ward y Xun Cao del departamento de Ciencias Políticas de la Universidad de Washington, asociado con datos de conflictos entre países en los años 90. El archivo conflict.RData contiene una lista con tres arreglos, X, Y, y D. X tiene tres campos: population (población en millones), gdp (PIB en millones de dolares) polity (puntuación política, un índice de democracia). Y hace referencia a una matriz \\(\\mathbf{Y}=[y_{i,j}]\\) en la que \\(y_{i,j}\\) representa el número de conflictos iniciados por el país \\(i\\) hacia el país \\(j\\). Finalmente, Des un arreglo de tres dimensiones dimensiones cuya tercera dimensión contiene indices entre cada par de países asociados con: comercio (dimensión 1), importaciones (dimensión 2), organizaciones intergubernamentales (dimensión 3), y distancia geográfica (dimensión 4).\na. Hacer una visualización decorada de la red de conflictos teniendo en cuenta diferentes diseños.\nb. Calcule e interprete la media global.\nc. Obtenga y grafique la distribución del out-degree y del in-degree. Calcule e interprete la media y la desviación estándar de esta distribución. \nd. Calcule el coeficiente de correlación entre los valores del out-degree y el in-degree. Realice un dispersograma de los grados de entrada (eje \\(y\\)) frente a los grados de salida (eje \\(x\\)), junto con la recta \\(y=x\\) como punto de referencia. ¿Qué se puede concluir?\ne. Identifique los países mas activos.",
    "crumbs": [
      "Talleres",
      "Taller 2"
    ]
  },
  {
    "objectID": "about.html#punto-7",
    "href": "about.html#punto-7",
    "title": "Taller 2",
    "section": "Punto 7",
    "text": "Punto 7\nPara todos los vértices de los cuatro grafos que se presentan a continuación, calcular el grado y las medidas de centralidad. Para cada grafo completar e interpretar la siguiente tabla. Interpretar los resultados.",
    "crumbs": [
      "Talleres",
      "Taller 2"
    ]
  },
  {
    "objectID": "about.html#punto-8",
    "href": "about.html#punto-8",
    "title": "Taller 2",
    "section": "Punto 8",
    "text": "Punto 8\nConsidere los datos relacionales acerca de los conflictos internacionales del archivo conflict.RData despúes de simetrizarla débilmente y remover los nodos aislados:\n\n# datos\n# load(\"conflict.RData\")\n# Y &lt;- dat$Y\n# # remover nodos aislados\n# Y &lt;- 1*( Y*t(Y) &gt; 0 )\n# deg &lt;- apply(X = Y, MARGIN = 1, FUN = sum, na.rm = TRUE)\n# Y &lt;- Y[deg &gt; 0, deg &gt; 0]\n\na. Hacer una visualización de la red.\nb. Caracterizar local y estructuralmente la red, en términos de la distancia, la centralidad, la cohesión, la conectivaidad, y el agrupamento. Utilizar todas las métricas disponbles.\nc. Interpretar los resultados",
    "crumbs": [
      "Talleres",
      "Taller 2"
    ]
  },
  {
    "objectID": "about.html#punto-9",
    "href": "about.html#punto-9",
    "title": "Taller 2",
    "section": "Punto 9",
    "text": "Punto 9\nSintetizar y replicar los Capítulos 6, 8, y 9 de Luke, D. A. (2015).",
    "crumbs": [
      "Talleres",
      "Taller 2"
    ]
  },
  {
    "objectID": "Taller2.html",
    "href": "Taller2.html",
    "title": "Taller 2",
    "section": "",
    "text": "El grado de un nodo en una red tanto dirigida como no dirigida se puede calcular fácilmente a partir de la matriz de adyacencia \\(\\mathbf{Y}=[y_{i,j}]\\). El out-degree \\(d_i^{\\text{out}}\\) y el in-degree \\(d_i^{\\text{in}}\\) del nodo \\(i\\) se pueden calcular respectivamente como: \\[\nd_i^{\\text{out}} = \\sum_{j:j\\neq i} y_{i,j}\n\\qquad\\text{y}\\qquad\nd_i^{\\text{in}} = \\sum_{j:j\\neq i} y_{j,i}\n\\] Muestre que si la red es no dirigida entonces \\(d_i^{\\text{out}} = d_i^{\\text{in}}\\).\nSi la red no es dirigida, \\(Y = [y_{ij}]\\) es simétrica, así \\(Y = [y_{ij}] = [y_{ji}] = Y^T\\), entonces:\n\\[\nd_i^{\\text{out}} = \\sum_{j:j \\neq i} y_{i,j}= \\sum_{j:j \\neq i} y_{j,i}  = d_i^{\\text{in}}\n\\]",
    "crumbs": [
      "Talleres",
      "Taller 2"
    ]
  },
  {
    "objectID": "Taller2.html#punto-1",
    "href": "Taller2.html#punto-1",
    "title": "Taller 2",
    "section": "",
    "text": "El grado de un nodo en una red tanto dirigida como no dirigida se puede calcular fácilmente a partir de la matriz de adyacencia \\(\\mathbf{Y}=[y_{i,j}]\\). El out-degree \\(d_i^{\\text{out}}\\) y el in-degree \\(d_i^{\\text{in}}\\) del nodo \\(i\\) se pueden calcular respectivamente como: \\[\nd_i^{\\text{out}} = \\sum_{j:j\\neq i} y_{i,j}\n\\qquad\\text{y}\\qquad\nd_i^{\\text{in}} = \\sum_{j:j\\neq i} y_{j,i}\n\\] Muestre que si la red es no dirigida entonces \\(d_i^{\\text{out}} = d_i^{\\text{in}}\\).\nSi la red no es dirigida, \\(Y = [y_{ij}]\\) es simétrica, así \\(Y = [y_{ij}] = [y_{ji}] = Y^T\\), entonces:\n\\[\nd_i^{\\text{out}} = \\sum_{j:j \\neq i} y_{i,j}= \\sum_{j:j \\neq i} y_{j,i}  = d_i^{\\text{in}}\n\\]",
    "crumbs": [
      "Talleres",
      "Taller 2"
    ]
  },
  {
    "objectID": "Taller2.html#punto-2",
    "href": "Taller2.html#punto-2",
    "title": "Taller 2",
    "section": "Punto 2",
    "text": "Punto 2\nTanto para redes dirigidas como no dirigidas, se define la media global de las interacciones como \\[\n\\bar{y}=\\frac{1}{n(n-1)}\\sum_{i,j:i\\neq j} y_{i,j}\n\\] donde \\(\\mathbf{Y}=[y_{i,j}]\\) es la matriz de adyacencia de la red correspondiente. Tal estadístico corresponde a una descripción muy rudimentaria acerca de la plausibilidad de observar una relación entre dos nodos cualesquiera, dado que no tiene en cuenta la heterogeneidad nodal (algunos nodos son más propensos a enviar/recibir más relaciones).\na. Muestre que para relaciones no dirigidas la media global \\(\\bar{y}\\) es igual a la media tanto de la parte triangular superior de \\(\\mathbf{Y}\\) como de la parte triangular inferior de \\(\\mathbf{Y}\\).\nComo la red es no dirigida, \\(Y = [y_{i,j}] = [y_{j,i}] = Y^T\\), por lo tanto: \\[\\sum_{i,j: i &gt; j} y_{i,j} = \\sum_{i,j: i &lt; j} y_{i,j}\\] Así: \\[\n\\bar{y}_{\\text{sup}} =  \\frac{2}{n(n-1)} \\sum_{i,j: i &gt; j} y_{i,j} = \\frac{2}{n(n-1)} \\sum_{i,j: i &lt; j} y_{i,j} = \\bar{y}_{\\text{inf}}\n\\]\nPor otro lado, \\[\\sum_{i,j: j \\neq i} y_{ij}\\] es una suma de 0’s y 1’s sobre toda la matriz \\(Y\\), entonces \\[\n\\frac{1}{2} \\sum_{i,j: i \\neq j} y_{i,j} =  \\sum_{i,j: i &lt; j} y_{i,j} = \\sum_{i,j: i &gt; j} y_{j,i}\n\\] Luego,\n\\[\n\\bar{y}=\\frac{1}{n(n-1)}\\sum_{i,j:i\\neq j} y_{i,j} = \\frac{2}{n(n-1)} \\sum_{i,j: i &gt; j} y_{i,j} = \\frac{2}{n(n-1)} \\sum_{i,j: i &lt;j} y_{i,j}\n\\]\nb. Muestre que tanto para relaciones dirigidas como no dirigidas la media global corresponde a la densidad de la red.\nRedes no dirigidas\nPara un subgrafo H, la densidad se define como \\[\n\\text{den}(H) = \\frac{|E_H|}{|V_H|(|V_H|-1)/2}\n\\] En una red no dirigida, la cantidad de aristas se puede calcular como la suma de la matriz triangular superior o inferior de la matriz de adyacencia Y: \\[\n|E_H| = \\sum_{i,j: i&gt;j} y_{i,j}\n\\] Por otro lado, \\(|V_H|\\) corresponde a la cantidad de vértices del grafo, que es igual al número de filas (n) o columnas (n) de la matriz de adyacencia.\n\\[\n\\text{den}(H)  = \\frac{2|E_H|}{|V_H|(|V_H|-1)} = \\frac{2}{n(n-1)} \\sum_{i,j:i&lt;j} y_{i,j}\n\\] Que, por el resultado anterior, es igual a: \\[\n\\bar{y}=\\frac{1}{n(n-1)}\\sum_{i,j:i\\neq j} y_{i,j}\n\\] Redes dirigidas\nEn una red no dirigida, la cantidad de aristas se puede calcular como la suma de la matriz de adyacencia Y: \\[\n\\sum_{i,j:i \\neq j} y_{ij}\n\\] y \\(|V_H|=n\\) como en el caso de una red no dirigida.\nAsí: \\[\n\\text{den}(H)  = \\frac{|E_H|}{|V_H|(|V_H|-1)} = \\frac{1}{n(n-1)} \\sum_{i,j:i \\neq j} y_{i,j} = \\bar{y}\n\\]\nc. Muestre que tanto para relaciones dirigidas como no dirigidas se tiene que \\((n-1)\\bar{y} = \\bar{d}^{\\text{out}}=\\bar{d}^{\\text{in}}\\). Es decir, el grado promedio tanto de entrada como de salida son iguales y a su vez equivalentes la densidad.\nRedes no dirigidas \\[\n(n-1)  \\bar{y} = (n-1)  \\frac{1}{n(n-1)} \\sum_{i,j: i \\neq j} y_{i,j} = \\frac{1}{n} \\sum_{i,j: i \\neq j} y_{i,j}\n\\] \\[\n= \\frac{1}{n} \\sum_{i=1}^n \\sum_{j=j \\neq i} y_{i,j} = \\frac{1}{n} \\sum_{i=1}^n d_i^{\\text{out}} = \\bar{d}^{\\text{out}}\n\\] según el resultado del punto 1, en una red no dirigida \\(d^{in} = d^{out}\\), luego \\[\n\\frac{1}{n} \\sum_{i=1}^n d_i^{\\text{out}} = \\frac{1}{n} \\sum_{i=1}^n d_i^{\\text{in}}\n\\] \\[\n\\bar{d}^{\\text{in}} = \\bar{d}^{\\text{out}}\n\\] Redes dirigidas\n\\[\nd_i^{\\text{in}} = \\sum_{j: j \\neq i} y_{j,i}\n\\]\n\\[\n\\bar{d}^{\\text{in}} =  \\frac{1}{n} \\sum_{i=1}^n \\sum_{j=j \\neq i} y_{j, i} =  \\frac{1}{n} \\sum_{i=1}^n \\sum_{j=j \\neq i} y_{i, j} = \\bar{d}^{\\text{out}}\n\\] \\(\\bar{d}^{\\text{in}}\\) se puede entender como una suma por columnas de la matriz de adyacencia sobre \\(n\\) y \\(\\bar{d}^{\\text{out}}\\) como una suma por filas de la matriz de adyacencia sobre \\(n\\).\nPor otro lado, \\[\n(n-1)  \\bar{y} = (n-1)  \\frac{1}{n(n-1)} \\sum_{i,j: i \\neq j} y_{i,j} = \\frac{1}{n} \\sum_{i,j: i \\neq j} y_{i,j}\n\\] \\[\n= \\frac{1}{n} \\sum_{i=1}^n \\sum_{j=j \\neq i} y_{i,j} = \\frac{1}{n} \\sum_{i=1}^n d_i^{\\text{out}} = \\bar{d}^{\\text{out}}  = \\bar{d}^{\\text{in}}\n\\]",
    "crumbs": [
      "Talleres",
      "Taller 2"
    ]
  },
  {
    "objectID": "Taller2.html#punto-3",
    "href": "Taller2.html#punto-3",
    "title": "Taller 2",
    "section": "Punto 3",
    "text": "Punto 3\nConsidere un grafo estrella de orden \\(n\\) y un grafo círculo de orden \\(n\\). A continuación se representan ambos grafos para \\(n=9\\). Estos grafos tienen aproximadamente la misma densidad, pero su estructura es muy diferente. Recuerde que la densidad de un grafo se puede calcular como el grado promedio dividido por \\(n - 1\\).\n\n\n\n\n\n\n\n\n\na. Muestre que para el grafo círculo de orden \\(n\\) el grado promedio es \\(\\bar{d} = 2\\).\nLa matriz de adyacencia para un grafo círculo de orden n, sería: \\[\nY_{n*n} =\n\\begin{bmatrix}\n. & 1 & . & . & . & . & . & . & 1 \\\\\n1 & . & 1 & . & . & . & . & . & . \\\\\n. & 1 & . & 1 & . & . & . & . & . \\\\\n. & . & 1 & . & 1 & . & . & . & . \\\\\n. & . & . & 1 & . & 1 & . & . & . \\\\\n. & . & . & . & 1 & . & 1 & . & . \\\\\n. & . & . & . & . & 1 & . & 1 & . \\\\\n. & . & . & . & . & . & 1 & . & 1 \\\\\n1 & . & . & . & . & . & . & 1 & . \\\\\n\\end{bmatrix}\n\\] En un grafo círculo, cada vértice tiene un grado de \\(2\\). Luego, la suma de todos los grados es: \\[\n\\sum_{i,j=i \\neq j} y_{i,j} = 2n\n\\] El grado promedio es: \\[\n\\bar{d} = (n-1) \\bar{y} =  (n-1)  \\frac{1}{n(n-1)} \\sum_{i,j: i \\neq j} y_{i,j} = \\frac{1}{n} 2n = 2\n\\]\nb. Muestre que para el grafo estrella de orden \\(n\\) el grado promedio es \\(\\bar{d} = 2\\frac{n-1}{n} \\rightarrow 2\\) cuando \\(n\\rightarrow\\infty\\).\nLa matriz de adyacencia para un grafo estrella de orden n, sería: \\[\nY_{n*n} =\n\\begin{bmatrix}\n. & . & . & . & . & . & . & . & 1 \\\\\n. & . & . & . & . & . & . & . & 1 \\\\\n. & . & . & . & . & . & . & . & 1 \\\\\n. & . & . & . & . & . & . & . & 1 \\\\\n. & . & . & . & . & . & . & . & 1 \\\\\n. & . & . & . & . & . & . & . & 1 \\\\\n. & . & . & . & . & . & . & . & 1 \\\\\n. & . & . & . & . & . & . & . & 1 \\\\\n1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & . \\\\\n\\end{bmatrix}\n\\] En un grafo estrella, cada vértice tiene una relación con el vértice central \\(n\\), con excepción del vértice central que tiene \\(n-1\\) relaciones. Esto implica: \\[\n|E| = (n-1) + (n-1) = 2n-2 = 2(n-1) = \\sum_{i,j: i \\neq j} y_{i,j}\n\\] Así, el grado promedio es: \\[\n\\bar{d} = (n-1) \\bar{y} =  (n-1)  \\frac{1}{n(n-1)} \\sum_{i,j: i \\neq j} y_{i,j} = \\frac{2(n-1)}{n}\n\\] Cuando \\({n \\to \\infty}\\),\n\\[\\bar{d} = 2\\frac{n-1}{n} = 2 \\frac{n}{n} \\frac{1}{n} = 2 \\frac{1}{n} \\rightarrow 2\\]",
    "crumbs": [
      "Talleres",
      "Taller 2"
    ]
  },
  {
    "objectID": "Taller2.html#punto-4",
    "href": "Taller2.html#punto-4",
    "title": "Taller 2",
    "section": "Punto 4",
    "text": "Punto 4\n¿Cuáles de las siguientes secuencias son caminatas en el grafo que se presenta a continuación? ¿Cuáles senderos? ¿Cuáles circuitos? ¿Cuáles ciclos?\n\n\n\n\n\n\n\n\n\na. \\(2 - 1 - 6 - 3 - 4\\).\n\ng4 &lt;- graph_from_literal(1-2,1-5,6-1,4-1,2-5,3-4,3-6)\n# Secuencia 2−1−6−3−4\nV_cam1 &lt;- c(2, 1, 6, 3, 4)\nE_cam1 &lt;- c(\"1-2\", \"1-6\", \"3-6\", \"3-4\")\nV(g4)$color &lt;- ifelse(V(g4)$name %in% V_cam1, \"red\", \"white\")\nE(g4)$color &lt;- ifelse(apply(ends(g4, E(g4)), 1, function(x) paste(sort(x), collapse=\"-\")) %in% E_cam1, \"red\", \"gray\")\nset.seed(3312)\nplot(g4, edge.arrow.size=1, vertex.size=20, vertex.label.cex=1, main=\"Secuencia 2−1−6−3−4\")\n\n\n\n\n\n\n\n\nEsta secuencia es un sendero, ya que es una caminata abierta que no tiene vertices ni aristas repetidas.\nb. \\(2 - 1 - 6 - 3 - 4 - 1 - 5\\).\n\n# Secuencia 2 - 1 - 6 - 3 - 4 - 1 - 5\nV_cam2 &lt;- c(2, 1, 6, 3, 4, 1, 5)\nE_cam2 &lt;- c(\"1-2\", \"1-6\", \"1-4\", \"1-5\", \"3-6\", \"3-4\")\nV(g4)$color &lt;- ifelse(V(g4)$name %in% V_cam2, \"red\", \"white\")\nE(g4)$color &lt;- ifelse(apply(ends(g4, E(g4)), 1, function(x) paste(sort(x), collapse=\"-\")) %in% E_cam2, \"red\", \"gray\")\nset.seed(3312)\nplot(g4, edge.arrow.size=1, vertex.size=20, vertex.label.cex=1, main=\"Secuencia 2-1-6-3-4-1-5\")\n\n\n\n\n\n\n\n\nEsta secuencia es un sendero, ya que es una caminata abierta que tiene vertices repetidos, pero no aristas repetidas.\nc. \\(2 - 1 - 2 - 5 - 1 - 4\\).\n\n# Secuencia 2 - 1 - 2 - 5 - 1 - 4\nV_cam3 &lt;- c(2, 1, 2, 5, 1, 4)\nE_cam3 &lt;- c(\"1-2\", \"2-1\", \"1-4\", \"1-5\", \"2-5\")\nV(g4)$color &lt;- ifelse(V(g4)$name %in% V_cam3, \"red\", \"white\")\nE(g4)$color &lt;- ifelse(apply(ends(g4, E(g4)), 1, function(x) paste(sort(x), collapse=\"-\")) %in% E_cam3, \"red\", \"gray\")\nset.seed(3312)\nplot(g4, edge.arrow.size=1, vertex.size=20, vertex.label.cex=1, main=\"Secuencia 2-1-2-5-1-4\")\n\n\n\n\n\n\n\n\nEsta secuencia es una caminata abierta que tiene vertices y aristas repetidas.",
    "crumbs": [
      "Talleres",
      "Taller 2"
    ]
  },
  {
    "objectID": "Taller2.html#punto-5",
    "href": "Taller2.html#punto-5",
    "title": "Taller 2",
    "section": "Punto 5",
    "text": "Punto 5\nConsidere el conjunto de datos dado en comtrade.RData (este archivo contiene una arreglo de cuatro dimensiones denominado comtrade), asociado con el crecimiento anual del comercio (diferencia en dólares en escala logarítmica respecto al año 2000). Este conjunto de datos involucra 30 países, 10 años desde 1996 hasta 2005, y 6 clases de productos diferentes, como se muestra a continuación:\n\nload(\"comtrade.RData\")\ndimnames(comtrade)[c(1,3,4)]\n\n[[1]]\n [1] \"Australia\"            \"Austria\"              \"Brazil\"              \n [4] \"Canada\"               \"China\"                \"China, Hong Kong SAR\"\n [7] \"Czech Rep.\"           \"Denmark\"              \"Finland\"             \n[10] \"France\"               \"Germany\"              \"Greece\"              \n[13] \"Indonesia\"            \"Ireland\"              \"Italy\"               \n[16] \"Japan\"                \"Malaysia\"             \"Mexico\"              \n[19] \"Netherlands\"          \"New Zealand\"          \"Norway\"              \n[22] \"Rep. of Korea\"        \"Singapore\"            \"Spain\"               \n[25] \"Sweden\"               \"Switzerland\"          \"Thailand\"            \n[28] \"Turkey\"               \"United Kingdom\"       \"USA\"                 \n\n[[2]]\n[1] \"Chemicals\"                                    \n[2] \"Crude materials, inedible, except fuels\"      \n[3] \"Food and live animals\"                        \n[4] \"Machinery and transport equipment\"            \n[5] \"Manufact goods classified chiefly by material\"\n[6] \"Miscellaneous manufactured articles\"          \n\n[[3]]\n [1] \"1996\" \"1997\" \"1998\" \"1999\" \"2000\" \"2001\" \"2002\" \"2003\" \"2004\" \"2005\"\n\n#View(comtrade[1,2,,]) # Paises, paises, productos y año\n\na. Calcule el aumento medio global \\(\\bar{y}\\) a lo largo de los 10 años en bienes manufacturados. Para ello considere la matriz de adyacencia Y dada por:\n\nY &lt;- apply(X = comtrade[,,c(5,6),], MARGIN = c(1,2), FUN = mean) #Media de años y bienes manufacturados\nn &lt;- dim(Y)[1]\nY[which(is.na(Y))] &lt;- 0 \n\n#** mean(y) **#\nround(sum(Y)/(n*(n-1)),4)\n\n[1] 0.0378\n\n\nb. Calcule la media de todas las observaciones de cada fila de Y, es decir, calcule la media fila \\(\\bar{y}_{i\\bullet}=\\frac{1}{n-1}\\sum_{j:j\\neq i} y_{i,j}\\) para cada país. Realice una histograma de los promedios fila \\(\\bar{y}_{i\\bullet}\\). Los promedios fila caracterizan diferentes niveles de actividad de los nodos en términos de la sociabilidad. ¿Cómo se pueden interpretar los promedios fila \\(\\bar{y}_{i\\bullet}\\)?\n\nmfila &lt;- apply(Y, MARGIN = 1, FUN = mean)\nmfila &lt;- data.frame(Fila = mfila, row.names = NULL)\n#hist(apply(Y, MARGIN = 1, FUN = mean))\nggplot(mfila, aes(x = Fila)) + \n  geom_histogram(alpha = 0.8, bins = 7, position = \"identity\", fill=\"purple\", colour = \"black\",lwd = 0.1,linetype = 1) +\nlabs(title=expression(paste(\"Media de observaciones por fila (\", bar(y)[i.], \")\")), x=\"Media de crecimiento anual en bienes manufacturados\", y=\"Frecuencia\") + mitema + \n  theme(strip.background=element_rect(color=\"black\",fill=\"gray80\",size=1), strip.text=element_text(face=\"bold\",size=15,vjust=0.5,hjust=0.5,color=\"black\",angle=0))\n\n\n\n\n\n\n\n\nLos promedios fila indican cuánto aumenta o disminuye, en promedio, el comercio saliente (exportaciones) de bienes manufacturados del país \\(i\\) hacia los demás países en comparación con el año 2000. De acuerdo al histograma, la mayoría de los paises, en promedio, aumentaron su comercio saliente a menos de 0.05 con respecto al 2000. Por otro lado, un país tuvo un comercio saliente promedio superior al de los demás países, lo que lo posiciona como el mayor exportador en los años de evaluación.\nc. Calcule la media de todas las observaciones de cada columna de Y, es decir, calcule la media columna \\(\\bar{y}_{\\bullet j}=\\frac{1}{n-1}\\sum_{i:i\\neq j} y_{i,j}\\) para cada país. Realice una histograma de los promedios columna \\(\\bar{y}_{\\bullet j}\\). Los promedios columna caracterizan diferentes niveles de actividad de los nodos en términos de la popularidad. ¿Cómo se pueden interpretar los promedios columna \\(\\bar{y}_{\\bullet j}\\)?\n\nmcol &lt;- apply(Y, MARGIN = 2, FUN = mean)\nmcol &lt;- data.frame(Col = mcol, row.names = NULL)\n#hist(apply(Y, MARGIN = 2, FUN = mean))\nggplot(mcol, aes(x = Col)) + \n  geom_histogram(alpha = 0.8, position = \"identity\", bins = 7, fill=\"purple\", colour = \"black\",lwd = 0.1,linetype = 1) +\nlabs(title=expression(paste(\"Media de observaciones por columna (\", bar(y)[.j], \")\")), x=\"Media de crecimiento anual en bienes manufacturados\", y=\"Frecuencia\") + mitema + \n  theme(strip.background=element_rect(color=\"black\",fill=\"gray80\",size=1), strip.text=element_text(face=\"bold\",size=15,vjust=0.5,hjust=0.5,color=\"black\",angle=0))\n\n\n\n\n\n\n\n\nLos promedios columna indican cuánto aumenta o disminuye, en promedio, el comercio entrante (importaciones) de bienes manufacturados hacia un país \\(i\\) desde los demás países en comparación con el año 2000. De acuerdo al histograma, algunos países, en promedio, disminuyeron su comercio entrante con respecto al 2000. Mientras que algunos pocos aumentaron sus importaciones a mas del 0.10 con el respecto al año 2000, lo que los posiciona como los mayores importadores en los años de evaluación.\nd. Calcule tanto la media de los promedios fila \\(\\bar{y}_{i\\bullet}\\) como la media de los promedios columna \\(\\bar{y}_{\\bullet j}\\). Qué se puede concluir acerca de la tendencia local en este caso?\n\nmeand &lt;- cbind(round(mean(mfila[,1]), 4), round(mean(mcol[,1]), 4))\ncolnames(meand) &lt;- c(\"Media promedios fila\", \"Media promedios columna\")\nrownames(meand) &lt;- NULL\nkable(meand, align = \"c\")\n\n\n\n\nMedia promedios fila\nMedia promedios columna\n\n\n\n\n0.0365\n0.0365\n\n\n\n\n\nLa media de los promedios fila y de los promedios columna es igual por como están definidas las medidas. Su valor es de 0.0365, el cual es cercano a 0, lo que indica que hubo un leve nivel de crecimiento económico tanto saliente como entrante de bienes manufacturados en comparación con el año 2000, en la red.\ne. Calcule tanto la DE de los promedios fila \\(\\bar{y}_{i\\bullet}\\) como la DE de los promedios columna \\(\\bar{y}_{\\bullet j}\\). ¿Qué se puede concluir acerca de la heterogeneidad local en este caso?\n\nsde &lt;- cbind(round(sd(mfila[,1]), 4), round(sd(mcol[,1]), 4))\ncolnames(sde) &lt;- c(\"DE promedios fila\", \"DE promedios columna\")\nrownames(sde) &lt;- NULL\nkable(sde, align = \"c\")\n\n\n\n\nDE promedios fila\nDE promedios columna\n\n\n\n\n0.0292\n0.0396\n\n\n\n\n\nLa desviación estándar de los promedios fila es inferior a la desviación estándar de los promedios columna, lo que indica que hay mayor heterogeneidad entre los niveles de importación de cada país que entre los de exportación. Así, en cuanto al nivel de exportación, el comercio saliente de los países dista, en promedio, 0.0292 de la media, mientras que el comercio entrante de los países dista, en promedio, 0.0396 de la media.\nf. Calcule el coeficiente de correlación entre los promedios fila \\(\\bar{y}_{i\\bullet}\\) y los promedios columna \\(\\bar{y}_{\\bullet j}\\). Realice un dispersograma de los promedios columna \\(\\bar{y}_{\\bullet j}\\) (eje \\(y\\)) frente a los promedios fila \\(\\bar{y}_{i\\bullet}\\) (eje \\(x\\)), junto con la recta \\(y=x\\) como punto de referencia. ¿Qué se puede concluir?\n\ntabf &lt;- cbind(mfila, mcol)\n# Coeficiente de correlacion\ncat(\"Coeficiente de correlación:\", round(cor(tabf)[1,2], 2))\n\nCoeficiente de correlación: 0.7\n\n# Grafico\nggplot(tabf,aes(x=Fila,y=Col)) +\ngeom_point(color=\"red\",shape=16,size=2.5)+\n  geom_abline(slope = 1, intercept = 0, color = \"blue\", linetype = \"solid\", size = 1) +\n  labs(title=\"Promedios fila versus promedios columna\",x=\"Promedios exportaciones\",y=\"Promedios importaciones\") +\n mitema\n\n\n\n\n\n\n\n\nEl coeficiente de correlación lineal entre los promedios fila y los promedios columna es de 0.7, lo que indica que hay una relación lineal alta. Así, si el promedio de exportaciones de un país \\(i\\) es alto, su promedio de importaciones también lo será. Por otro lado, según el dispersograma, el promedio de las exportaciones y de las importaciones en los países tiende a mantener una magnitud y signo similar que puede ser representada por la recta \\(x=y\\), por supuesto, con la presencia de ciertos países que parecen no seguir dicha relación.",
    "crumbs": [
      "Talleres",
      "Taller 2"
    ]
  },
  {
    "objectID": "Taller2.html#punto-6",
    "href": "Taller2.html#punto-6",
    "title": "Taller 2",
    "section": "Punto 6",
    "text": "Punto 6\nConsidere el conjunto de datos dado en conflict.RData recopilado por Mike Ward y Xun Cao del departamento de Ciencias Políticas de la Universidad de Washington, asociado con datos de conflictos entre países en los años 90. El archivo conflict.RData contiene una lista con tres arreglos, X, Y, y D. X tiene tres campos: population (población en millones), gdp (PIB en millones de dolares) polity (puntuación política, un índice de democracia). Y hace referencia a una matriz \\(\\mathbf{Y}=[y_{i,j}]\\) en la que \\(y_{i,j}\\) representa el número de conflictos iniciados por el país \\(i\\) hacia el país \\(j\\). Finalmente, Des un arreglo de tres dimensiones dimensiones cuya tercera dimensión contiene indices entre cada par de países asociados con: comercio (dimensión 1), importaciones (dimensión 2), organizaciones intergubernamentales (dimensión 3), y distancia geográfica (dimensión 4).\na. Hacer una visualización decorada de la red de conflictos teniendo en cuenta diferentes diseños.\nTeniendo en cuenta la fuerza, se determina el tamaño del nodo. Además, los países con índice de democracio mayor que 0 son de color azul claro, mientras que los demás de color azul oscuro.\n\nload(\"conflict.RData\")\ng6 &lt;- graph_from_adjacency_matrix(dat$Y, mode = \"directed\", weighted = TRUE, diag = FALSE)\n# Nombres de vértices\nV(g6)$name &lt;- rownames(dat$X)\n\n# Graficos interactivos\n# Opción 1\n#simpleNetwork(data.frame(as_edgelist(g6)))\n\n# Opción 2\nnodes &lt;- data.frame(name = V(g6)$name)\nnodes$id &lt;- 0:(nrow(nodes) - 1)  # IDs numéricos empezando en 0\nnodes$pob &lt;- dat$X[,1]\nnodes$nodesize &lt;- igraph::degree(g6)\nnodes$polity &lt;- ifelse(dat$X[,3] &gt; 0, \"polity &gt; 0\", \"polity &lt; 0\")\nnodes$gdp &lt;- dat$X[,2]\n\nlinks &lt;- as_data_frame(g6, what = \"edges\")\nlinks$source_id &lt;- match(links$from, nodes$name) - 1\nlinks$target_id &lt;- match(links$to, nodes$name) - 1\n\n## Layout \nset.seed(1208)\n# b&lt;-layout_as_star(g6); c&lt;-layout_as_tree(g6);d&lt;-layout_in_circle(g6);f&lt;-layout_on_grid(g6);g&lt;-layout_on_sphere(g6);i&lt;-layout_with_dh(g6);j&lt;-layout_with_fr(g6);k&lt;-layout_with_gem(g6);l&lt;-layout_with_graphopt(g6);m&lt;-layout_with_kk(g6);n&lt;-layout_with_lgl(g6);o&lt;-layout_with_mds(g6);p&lt;-layout_with_sugiyama(g6)\ne&lt;-layout_nicely(g6)\nV(g6)$color &lt;- ifelse(dat$X[,3] &gt; 0, \"lightblue\", \"blue\")\n\n#  Teniendo en cuenta la fuerza\nplot(g6, layout = e, vertex.size = 7* sqrt(strength(g6, weights = NA)), vertex.label = NA,\n     vertex.color = adjustcolor(V(g6)$color, 0.4),\n     edge.color = adjustcolor(\"gray\", 0.4), edge.arrow.size = 0.3) \n\n\n\n\n\n\n\n#title(main = \"Red de Conflictos\", outer = TRUE, line = -2)\n\nTeniendo en cuenta el tamaño de la población, se determina el tamaño del nodo. Además, los países con índice de democracio mayor que 0 son de color naranja, mientras que los demás de color azul.\n\n# Teniendo en cuenta la poblacion\nforceNetwork(Links = links, Nodes = nodes,\n             Source = \"source_id\", Target = \"target_id\", linkColour = \"gray\",\n             NodeID = \"name\", Group = \"polity\", Nodesize = \"pob\",\n             radiusCalculation=\"Math.sqrt(d.nodesize)*0.8\", fontSize = 20,  legend=TRUE,\n             opacity = 0.9, colourScale = JS(\"d3.scaleOrdinal(d3.schemeCategory10);\"))\n\n\n\n\n\nTeniendo en cuenta el PIB, se determina el tamaño del nodo. Además, los países con índice de democracio mayor que 0 son de color naranja, mientras que los demás de color azul.\n\n# Teniendo en cuenta el PIB\nforceNetwork(Links = links, Nodes = nodes,\n             Source = \"source_id\", Target = \"target_id\", linkColour = \"gray\",\n             NodeID = \"name\", Group = \"polity\", Nodesize = \"gdp\",\n             radiusCalculation=\"Math.sqrt(d.nodesize)*0.5\", fontSize = 20,  legend=TRUE,\n             opacity = 0.9, colourScale = JS(\"d3.scaleOrdinal(d3.schemeCategory10);\"))\n\n\n\n\n\nb. Calcule e interprete la media global.\n\nn &lt;- nrow(dat$Y)\ncat(\"Media global:\", round(sum(dat$Y)/(n*(n-1)),4))\n\nMedia global: 0.0182\n\n\nLa media global de la red es cercana a 0, lo que indica que hay pocas posibilidades de que dos países tengan alguna relación de conflicto, omitiendo si los países son propensos a recibir u omitir este tipo de relaciones.\nc. Obtenga y grafique la distribución del out-degree y del in-degree. Calcule e interprete la media y la desviación estándar de esta distribución.\ndout &lt;- igraph::degree(g6, mode = \"out\")\ndtdout &lt;- data.frame(table(factor(dout, levels = 0:names(table(dout))[length(table(dout))])))\ncolnames(dtdout) &lt;- c(\"Grado\", \"Frec\") \ndtdout[,2] &lt;- dtdout[,2]/n\n\nggplot(dtdout, aes(x = Grado, weight=Frec)) + \n  geom_bar(position=position_dodge(),width=0.75, fill= \"purple\") + \n  scale_y_continuous(breaks=seq(from=0,to=0.5,by=0.1)) +\n  scale_x_discrete(breaks=seq(from=0,to=30,by=5)) +\n labs(title=\"Distribución del grado de salida\", x=\"Grado de salida\", y=\"Densidad\")+\nmitema \ndin &lt;- igraph::degree(g6, mode = \"in\")\ndtdin &lt;- data.frame(table(factor(din, levels = 0:names(table(din))[length(table(din))])))\ncolnames(dtdin) &lt;- c(\"Grado\", \"Frec\") \ndtdin[,2] &lt;- dtdin[,2]/n\n\nggplot(dtdin, aes(x = Grado, weight=Frec)) + \n  geom_bar(position=position_dodge(),width=0.75, fill= \"purple\") + \n  scale_y_continuous(breaks=seq(from=0,to=0.5,by=0.1)) +\n  scale_x_discrete(breaks=seq(from=0,to=30,by=5)) +\n labs(title=\"Distribución del grado de entrada\", x=\"Grado de entrada\", y=\"Densidad\")+\nmitema \n\n\n\n\n\n\n\n\n\n\n\nmeand &lt;- rbind(cbind(round(mean(din), 4), round(mean(dout), 4)), cbind(round(sd(din), 4), round(sd(dout), 4)))\n\ncolnames(meand) &lt;- c(\"Grado de entrada\", \"Grado de salida\")\nrownames(meand) &lt;- c(\"Media\", \"Desviación estándar\")\nkable(meand, align = \"c\")\n\n\n\n\n\nGrado de entrada\nGrado de salida\n\n\n\n\nMedia\n1.5615\n1.5615\n\n\nDesviación estándar\n1.9845\n3.5894\n\n\n\n\n\nLa media del grado de entrada y de salida es de 1.56, lo que indica que, en promedio, los países inician o reciben un conflicto aproximadamente dos veces con otro países. Sin embargo, existe mayor heterogeneidad en las relaciones de conflicto que emiten los países, que entre las que reciben.\nPor otro lado, de acuerdo con las distribuciones de los grados de entrada como de salida, pocos países inician o reciben relaciones de conflicto más de 15 veces, por lo que estos países podrían ser centros o autoridades.\nd. Calcule el coeficiente de correlación entre los valores del out-degree y el in-degree. Realice un dispersograma de los grados de entrada (eje \\(y\\)) frente a los grados de salida (eje\\(x\\)), junto con la recta \\(y=x\\) como punto de referencia. ¿Qué se puede concluir?\n\ntabd &lt;- cbind(din, dout)\n# Coeficiente de correlacion\ncat(\"Coeficiente de correlación:\", round(cor(tabd)[1,2], 2))\n\nCoeficiente de correlación: 0.6\n\n# Grafico\nggplot(tabd,aes(x=dout,y=din)) +\ngeom_point(color=\"red\",shape=16,size=2.5)+\ngeom_abline(slope = 1, intercept = 0, color = \"blue\", linetype = \"solid\", size = 1) + \n  labs(title=\"Grados de entrada versus grados de salida\",x=\"Grados de salida\",y=\"Grados de entrada\") +\n mitema\n\n\n\n\n\n\n\n\nEl coeficiente de correlación lineal entre los grados de entrada y de salida es de 0.6, lo que indica que hay una relación lineal moderada. Así, si las relaciones de conflicto que un país inicia hacia otro aumentan, las relaciones de conflicto recibidas también lo hacen, pero de manera moderada.\nPor otro lado, según el dispersograma, la mayoría de los países tienen menos de 5 conflictos iniciados y recibidos, pero existen dos países que tienen más de 20 conflictos iniciados hacia otros países y uno de ellos ha recibido 15 relaciones de conflicto.\ne. Identifique los países mas activos.\nPor grado\n# De entrada\ntopdin &lt;- head(sort(din,decreasing = T),5)\nkable(data.frame(Vertice = names(topdin), GradoIn = topdin, row.names = NULL), align = 'c')\n# De salida\ntopdout &lt;- head(sort(dout, decreasing = T), n = 5)\nkable(data.frame(Vertice = names(topdout), GradoOut = topdout, row.names = NULL), align = 'c')\n\n\n\n\n\n\nVertice\nGradoIn\n\n\n\n\nIRQ\n15\n\n\nUSA\n8\n\n\nHAI\n7\n\n\nTUR\n6\n\n\nJPN\n5\n\n\n\n\n\n\n\n\nVertice\nGradoOut\n\n\n\n\nIRQ\n27\n\n\nJOR\n26\n\n\nUSA\n11\n\n\nUGA\n7\n\n\nCHN\n6\n\n\n\n\n\n\nTeniendo en cuenta el grado de entrada, el pais más activo en cuanto a recibir relaciones de conflicto es IRAQ, pues es el que más paises le han omitido este tipo de relaciones. De acuerdo al grado de salida, los paises más propensos a emitir relaciones de conflicto son IRAQ y JORDANIA, pues son los que más se han dirigido hacia otros paises con relaciones de conflicto.\nPor fuerza\n# De entrada\ntopwdin &lt;- head(sort(strength(g6, mode = \"in\"), decreasing = T), n = 5)\nkable(data.frame(Vertice = names(topwdin), FuerzaIn = topwdin, row.names = NULL), align = 'c')\n# De salida\ntopwdout &lt;- head(sort(strength(g6, mode = \"out\"), decreasing = T), n = 5)\nkable(data.frame(Vertice = names(topwdout), FuerzaOut = topwdout, row.names = NULL), align = 'c')\n\n\n\n\n\n\nVertice\nFuerzaIn\n\n\n\n\nIRQ\n40\n\n\nUSA\n13\n\n\nGRC\n10\n\n\nJPN\n10\n\n\nCHN\n8\n\n\n\n\n\n\n\n\nVertice\nFuerzaOut\n\n\n\n\nIRQ\n30\n\n\nJOR\n26\n\n\nTUR\n20\n\n\nUSA\n18\n\n\nPRK\n16\n\n\n\n\n\n\nTeniendo en cuenta la fuerza de entrada, los paises más propensos a recibir relaciones de conflicto son IRAQ y USA, pues estos son los que más han recibido relaciones de conflicto desde otros paises. De acuerdo a la fuerza de salida, los paises más propensos a emitir relaciones de conflicto son IRAQ, JORDANIA y TURQUIA pues estos son los que más han iniciado relaciones de conflicto hacia otros paises.\nCentros o autoridades\n\n# Centros\nhs &lt;- round(igraph::hub_score(graph = g6, scale = T)$vector,2)\nhead(sort(hs,decreasing = T),5)\n\n TUR  USA  IRN  UKG  FRN \n1.00 0.78 0.64 0.52 0.42 \n\n# Autoridades\nas &lt;- round(igraph::authority_score(graph = g6, scale = T)$vector, 2)\nhead(sort(as,decreasing = T),5)\n\n IRQ  GRC  CYP  IRN  SYR \n1.00 0.39 0.14 0.14 0.12 \n\n\nLos países que más relaciones emiten a países centrales en las relciones de conflicto son TURQUIA, USA e IRAN. Mientras que los países que más relaciones reciben de estos países centrales son IRAQ y GRECIA.",
    "crumbs": [
      "Talleres",
      "Taller 2"
    ]
  },
  {
    "objectID": "Taller2.html#punto-7",
    "href": "Taller2.html#punto-7",
    "title": "Taller 2",
    "section": "Punto 7",
    "text": "Punto 7\nPara todos los vértices de los cuatro grafos que se presentan a continuación, calcular el grado y las medidas de centralidad. Para cada grafo completar e interpretar la siguiente tabla. Interpretar los resultados.\n\n# Funcion\nfun7 &lt;- function(grafo){\n  #Grado\n  d &lt;- igraph::degree(graph = grafo)\n  \n  #Centralidad de cercanía\n  clss &lt;- igraph::closeness(graph = grafo, normalized = T)\n  #Centralidad de intermediación\n  btw &lt;- igraph::betweenness(graph = grafo, normalized = T)\n  #Centralidad de propia\n  ev &lt;- igraph::eigen_centrality(graph = grafo, scale = T)$vector\n\n  tabla &lt;- data.frame(\n  Medida = c(\"Media\", \"Desviacion estándar\"),\n  Grado = c(round(mean(d),2), round(sd(d), 2)),\n  Cercania = c(round(mean(clss),2), round(sd(clss), 2)),\n  Intermediacion = c(round(mean(btw),2), round(sd(btw), 2)),\n  Propia = c(round(mean(ev),2), round(sd(ev), 2))\n)\nreturn(list(Grado = d, Cercania = clss, Intermediacion = btw, Propia= ev, Tabla = tabla))\n}\n\nGrafo1\n\ng1 &lt;- graph_from_literal(2-1, 3-1, 4-1, 5-1)\nset.seed(123)\nplot(g1, vertex.size=35, vertex.color=\"gray\", edge.color=\"gray\", vertex.label.cex=1, vertex.label.color=\"black\")\n\n\n\n\n\n\n\n\nResumén de vértices y de grafo\nG1 = fun7(g1)\n\nWarning: The `scale` argument of `eigen_centrality()` is deprecated as of igraph 2.1.1.\nℹ eigen_centrality() will always behave as if scale=TRUE were used.\n\n# Resumen vertice \nResV &lt;- rbind(Grado = G1$Grado, Cernacia = round(G1$Cercania, 2), Intermediacion = round(G1$Intermediacion, 2), Propia = round(G1$Propia, 2)\n)\nResV &lt;- ResV[, order(as.numeric(colnames(ResV)))]\nkable(ResV, align=\"c\")\n# Resumen grafo\nkable(G1$Tabla, align = \"c\")\n\n\n\n\n\n\n\n1\n2\n3\n4\n5\n\n\n\n\nGrado\n4\n1.00\n1.00\n1.00\n1.00\n\n\nCernacia\n1\n0.57\n0.57\n0.57\n0.57\n\n\nIntermediacion\n1\n0.00\n0.00\n0.00\n0.00\n\n\nPropia\n1\n0.50\n0.50\n0.50\n0.50\n\n\n\n\n\n\n\n\nMedida\nGrado\nCercania\nIntermediacion\nPropia\n\n\n\n\nMedia\n1.60\n0.66\n0.20\n0.60\n\n\nDesviacion estándar\n1.34\n0.19\n0.45\n0.22\n\n\n\n\n\n\nSegún la tabla de resumen del grafo, cada nodo tiene en promedio 1 relación con otro nodo.\nEn promedio, cada nodo es moderadamente cercano a los otros y cada uno dista, en promedio, 0.19 de la medida de cercanía, lo que los hace homogéneos.\nEn promedio, los nodos tienden a no estar entre otros pares de nodos, pero su medida de intermediación es heterogénea.\nEn promedio, los nodos están alrededor de nodos que son importantes en la red y cada uno dista, en promedio, 0.22 de la medida, lo que los hace homogéneos.\nGrafo 2\n\ng2 &lt;- graph_from_literal(1-2, 2-3, 3-4, 3-5)\nset.seed(123)\nplot(g2, vertex.size=45, vertex.color=\"gray\", edge.color=\"gray\", vertex.label.cex=1, vertex.label.color=\"black\")\n\n\n\n\n\n\n\n\nResumén de vértices y de grafo\nG2 = fun7(g2)\n# Resumen vertice \nResV &lt;- rbind(Grado = G2$Grado, Cernacia = round(G2$Cercania, 2), Intermediacion = round(G2$Intermediacion, 2), Propia = round(G2$Propia, 2)\n)\nResV &lt;- ResV[, order(as.numeric(colnames(ResV)))]\nkable(ResV, align=\"c\")\n# Resumen grafo\nkable(G2$Tabla, align = \"c\")\n\n\n\n\n\n\n\n1\n2\n3\n4\n5\n\n\n\n\nGrado\n1.00\n2.00\n3.00\n1.00\n1.00\n\n\nCernacia\n0.44\n0.67\n0.80\n0.50\n0.50\n\n\nIntermediacion\n0.00\n0.50\n0.83\n0.00\n0.00\n\n\nPropia\n0.41\n0.77\n1.00\n0.54\n0.54\n\n\n\n\n\n\n\n\nMedida\nGrado\nCercania\nIntermediacion\nPropia\n\n\n\n\nMedia\n1.60\n0.58\n0.27\n0.65\n\n\nDesviacion estándar\n0.89\n0.15\n0.38\n0.23\n\n\n\n\n\n\nSegún la tabla de resumen del grafo, cada nodo tiene en promedio 1 relación con otro nodo, pero la desviación estándar indica que hay variabilidad de aproximademante una relación entre estos y la media.\nEn promedio, cada nodo es moderadamente cercano a los otros y cada uno dista, en promedio, 0.15 de la medida de cercanía, lo que los hace homogéneos.\nEn promedio, los nodos tienden a no estar entre otros pares de nodos, pero su medida de intermediación es heterogénea, por lo que algunos pueden si estarlo.\nEn promedio, los nodos están alrededor de nodos que son importantes en la red y cada uno dista, en promedio, 0.23 de la medida, lo que los hace homogéneos.\nGrafo 3\n\ng3 &lt;- graph_from_literal(1-2, 2-3, 3-4, 4-5)\nset.seed(123)\nplot(g3, vertex.size=45, vertex.color=\"gray\", edge.color=\"gray\", vertex.label.cex=1, vertex.label.color=\"black\")\n\n\n\n\n\n\n\n\nResumén de vértices y de grafo\nG3 = fun7(g3)\n# Resumen vertice \nResV &lt;- rbind(Grado = G3$Grado, Cernacia = round(G3$Cercania, 2), Intermediacion = round(G3$Intermediacion, 2), Propia = round(G3$Propia, 2)\n)\nResV &lt;- ResV[, order(as.numeric(colnames(ResV)))]\nkable(ResV, align=\"c\")\n# Resumen grafo\nkable(G3$Tabla, align = \"c\")\n\n\n\n\n\n\n\n1\n2\n3\n4\n5\n\n\n\n\nGrado\n1.0\n2.00\n2.00\n2.00\n1.0\n\n\nCernacia\n0.4\n0.57\n0.67\n0.57\n0.4\n\n\nIntermediacion\n0.0\n0.50\n0.67\n0.50\n0.0\n\n\nPropia\n0.5\n0.87\n1.00\n0.87\n0.5\n\n\n\n\n\n\n\n\nMedida\nGrado\nCercania\nIntermediacion\nPropia\n\n\n\n\nMedia\n1.60\n0.52\n0.33\n0.75\n\n\nDesviacion estándar\n0.55\n0.12\n0.31\n0.23\n\n\n\n\n\n\nSegún la tabla de resumen del grafo, cada nodo tiene en promedio 1 relación con otro nodo, pero la desviación estándar indica que hay variabilidad de aproximademante una relación entre estos y la media.\nEn promedio, cada nodo es moderadamente cercano a los otros y cada uno dista, en promedio, 0.12 de la medida de cercanía, lo que los hace homogéneos.\nEn promedio, los nodos tienden a estar moderadamente entre otros pares de nodos y su medida de intermediación es heterogénea, por lo que algunos nodos pueden tener una medida alta.\nEn promedio, los nodos tienden a estar alrededor de nodos que son importantes en la red y cada uno dista, en promedio, 0.23 de la medida, lo que los hace homogéneos.\nGrafo 4\n\ng4 &lt;- graph_from_literal(1-2, 2-3, 3-4, 4-5, 5-1)\nset.seed(123)\nplot(g4, vertex.size=45, vertex.color=\"gray\", edge.color=\"gray\", vertex.label.cex=1, vertex.label.color=\"black\")\n\n\n\n\n\n\n\n\nResumén de vértices y de grafo\nG4 = fun7(g4)\n# Resumen vertice \nResV &lt;- rbind(Grado = G4$Grado, Cernacia = round(G4$Cercania, 2), Intermediacion = round(G4$Intermediacion, 2), Propia = round(G4$Propia, 2)\n)\nResV &lt;- ResV[, order(as.numeric(colnames(ResV)))]\nkable(ResV, align=\"c\")\n# Resumen grafo\nkable(G4$Tabla, align = \"c\")\n\n\n\n\n\n\n\n1\n2\n3\n4\n5\n\n\n\n\nGrado\n2.00\n2.00\n2.00\n2.00\n2.00\n\n\nCernacia\n0.67\n0.67\n0.67\n0.67\n0.67\n\n\nIntermediacion\n0.17\n0.17\n0.17\n0.17\n0.17\n\n\nPropia\n1.00\n1.00\n1.00\n1.00\n1.00\n\n\n\n\n\n\n\n\nMedida\nGrado\nCercania\nIntermediacion\nPropia\n\n\n\n\nMedia\n2\n0.67\n0.17\n1\n\n\nDesviacion estándar\n0\n0.00\n0.00\n0\n\n\n\n\n\n\nSegún la tabla de resumen del grafo, cada nodo tiene 2 relaciones con otros nodos.\nCada nodo es moderadamente cercano a los otros y todos tienen la misma medida de cercanía.\nLos nodos no tienden a estar entre otros pares de nodos y todos tienen la misma medida de intermediación.\nTodos los nodos están alrededor de nodos que son importantes en la red.\nEn general, el grafo que presenta la cualidad de tener nodos que esten alrededor de nodos importantes es el último. Además, también es el grafo que tiene más nodos cercanos de otros.",
    "crumbs": [
      "Talleres",
      "Taller 2"
    ]
  },
  {
    "objectID": "Taller2.html#punto-8",
    "href": "Taller2.html#punto-8",
    "title": "Taller 2",
    "section": "Punto 8",
    "text": "Punto 8\nConsidere los datos relacionales acerca de los conflictos internacionales del archivo conflict.RData despúes de simetrizarla débilmente y remover los nodos aislados:\n\nload(\"conflict.RData\")\ng8 &lt;- graph_from_adjacency_matrix(dat$Y, mode = \"directed\", weighted = TRUE)\n\n# Simetrizacion debil\ng8 &lt;- as_undirected(g8, mode = \"collapse\")\nis_directed(g8)\n\n[1] FALSE\n\nV(g8)$name &lt;- rownames(dat$X)\n\nV(g8)$id &lt;- 0:(vcount(g8) - 1)  # IDs numéricos empezando en 0\nV(g8)$nodesize &lt;- igraph::degree(g8)\nV(g8)$polity &lt;- ifelse(dat$X[,3] &gt; 0, \"polity &gt; 0\", \"polity &lt; 0\")\n\n# Remover nodos aislados \ng8 &lt;- igraph::delete_vertices(g8, which(igraph::degree(g8) == 0))\ntable(igraph::degree(g8))\n\n\n 1  2  3  4  5  6  7  8 14 27 29 \n29 16 15 13  4  7  2  2  1  1  1 \n\n\na. Hacer una visualización de la red.\n\n# Interactivo\n\nlinks &lt;- as_data_frame(g8, what = \"edges\")\nlinks$source_id &lt;- match(links$from, V(g8)$name) - 1\nlinks$target_id &lt;- match(links$to, V(g8)$name) - 1\n\nnodes &lt;- data.frame(name = V(g8)$name)\nnodes$id &lt;- V(g8)$id  # IDs numéricos empezando en 0\nnodes$nodesize &lt;- V(g8)$nodesize\nnodes$polity &lt;- V(g8)$polity\n\n# Teniendo en cuenta el grado\nforceNetwork(Links = links, Nodes = nodes,\n             Source = \"source_id\", Target = \"target_id\", linkColour = \"gray\",\n             NodeID = \"name\", Group = \"polity\", Nodesize = \"nodesize\",\n             radiusCalculation=\"Math.sqrt(d.nodesize)*3\", fontSize = 20,  legend=TRUE,\n             opacity = 0.9, colourScale = JS(\"d3.scaleOrdinal(d3.schemeCategory10);\"))\n\n\n\n\n\nb. Caracterizar local y estructuralmente la red, en términos de la distancia, la centralidad, la cohesión, la conectivaidad, y el agrupamento. Utilizar todas las métricas disponbles. C. Interpretar los resultados\nDistancia\n\n# Matriz de Distancias \nD &lt;- distances(graph = g8, v = V(g8), to = V(g8))\n\n# Diámetro \ncat(\"La distancia más larga entre los países del grafo es de:\" , diameter(g8), \"\\n\")\n\nLa distancia más larga entre los países del grafo es de: 18 \n\n# Sendero del diametro \nd &lt;- get_diameter(g8)\ncat(\"Los países que se deben recorrer en el sendero del diametro son:\", \"\\n\")\n\nLos países que se deben recorrer en el sendero del diametro son: \n\nd\n\n+ 11/91 vertices, named, from 33866a5:\n [1] CAM THI MYA BNG JOR USA VEN COL NIC SAL HON\n\n# Visualización del diámetro \nV(g8)$color &lt;- \"white\"\nE(g8)$color &lt;- \"grey\"\nE(g8)$width &lt;- 1\nV(g8)[d]$color &lt;- \"red\"\nE(g8, path = d)$color &lt;- \"red\"\nE(g8, path = d)$width &lt;- 2\nset.seed(123)\nplot(g8, vertex.label= NA)\n\n\n\n\n\n\n\n\n\n# Distancia geodésica promedio\nresumen &lt;- NULL\nresumen &lt;- rbind(resumen, round(mean_distance(g8),3))\ncolnames(resumen)  &lt;- \"Grafo\"\ncat(\"La distancia geodésica promedio es de\", round(mean_distance(g8),3), \"\\n\" )\n\nLa distancia geodésica promedio es de 5.072 \n\n\nEn promedio, cada país está separado de los demás en 5.\n\n# Distribución de las distancias \nsenderos &lt;- distance_table(g8)$res\nnames(senderos) &lt;- 1:length(senderos)\nbarplot(prop.table(senderos), xlab = \"Distancia geodésica\", ylab = \"F. Relativa\", border = \"grey\", col = \"grey\", main = \"Distribución de distancias geodésicas\")\n\n\n\n\n\n\n\n\nDe acuerdo al gráfico, la distribución de las distancias entre los países se acumula en un rango de 1 a 7\nCentralidad\n\n# Grado de cada vertice\nd &lt;- igraph::degree(g8, mode = \"all\")\nhead(sort(d, decreasing = T), n = 5)\n\nIRQ JOR USA CHN UGA \n 29  27  14   8   8 \n\n\nLos países que más se han relacionado con diferentes países en relaciones de conflicto son IRAQ y JORDANIA.\n\nresumen &lt;- rbind(resumen,  round(mean(d),3))\ncat(\"El grado promedio del grafo es de:\", round(mean(d),2), \"\\n\")\n\nEl grado promedio del grafo es de: 3.52 \n\ncat(\"La desviación del grado es de:\", round(sd(d),2), \"\\n\")\n\nLa desviación del grado es de: 4.29 \n\n\nEn promedio, cada país está involucrado en relaciones de conflicto con tres paises, pero los grados de los nodos tienden a ser heterogeneos según la desviación estándar.\n\n#Distribución del grado\ndd &lt;- degree_distribution(g8)\n\n#Visualización\npar(mfrow = c(1,2))\nplot(NA, NA, type = \"n\", xlim = c(0,30), ylim = c(0,0.2), xlab = \"Grado\", ylab = \"Densidad\", main = \"Distribución de grado\")\nhist(d, freq = F, col = \"cyan\", border = \"royalblue\", add = T)\nplot((0:max(d))[dd != 0], dd[dd != 0], log = \"xy\", pch = 16, col = adjustcolor(\"royalblue\", 0.5), xlab = \"Log-grado\", ylab = \"Log-densidad\", main = \"Distribución de grado (log-log)\")\n\n\n\n\n\n\n\n\nLa distribución del grado es sesgada a la derecha, por lo que la mayoría de países tienen relaciones de conflicto con menos de 5 países.\n\n# Fuerza de cada vertice\nwd &lt;- strength(g8)\nhead(sort(wd, decreasing = T), n = 5)\n\nIRQ USA JOR TUR PRK \n 70  31  27  27  23 \n\n\nLos países que mayor cantidad de conflictos tienen son IRAQ y USA.\n\nresumen &lt;- rbind(resumen, round(mean(wd),2))\ncat(\"La fuerza promedio del grafo es de:\", round(mean(wd),2), \"\\n\")\n\nLa fuerza promedio del grafo es de: 6.7 \n\n\nEn promedio, los países tienen 7 relaciones de conflicto con los demás países.\n\n# Grado promedio de los vecinos  más cercados de orden 1\nmnd &lt;- knn(graph = g8, vids = V(g8))$knn\ncat(\"El grado promedio de los vecinos  más cercados de orden 1 es de:\", mean(d[as.numeric(neighbors(graph = g8, v = 1))]))\n\nEl grado promedio de los vecinos  más cercados de orden 1 es de: 10\n\n\nEn promedio, los países que están directamente conectados con otro país, tienen relaciones de conflicto con 10 países.\n\n# Cercanía\nclss &lt;- igraph::closeness(g8, normalized = TRUE)\nhead(sort(clss, decreasing = T), n = 5)\n\nMAL MZM SIN SWA LES \n1.0 1.0 1.0 1.0 0.5 \n\n\nLos países más cercanos a otros países son Malasia, Mozambique, Singapur y Suazilandia.\n\nresumen &lt;- rbind(resumen, round(mean(clss), 3))\ncat(\"La cercanía promedio del grafo es de: \", round(mean(clss), 2), \"\\n\")\n\nLa cercanía promedio del grafo es de:  0.26 \n\n\nEn promedio, los países en la red de conflictos no presentan tanta cercanía unos entre otros.\n\n# Intermediación \nbtw &lt;- igraph::betweenness(g8, normalized = TRUE)\nhead(sort(btw, decreasing = T), n = 5)\n\n      JOR       USA       IRQ       VEN       CHA \n0.4811380 0.2441667 0.1539473 0.1338327 0.1292385 \n\n\nEl país JORDANIA es un país moderadamente importante en la red, pues se encuentra en las relaciones de conflicto entre otros pares de países.\n\nresumen &lt;- rbind(resumen, round(mean(btw), 3))\ncat(\"La intermediación promedio del grafo es de: \", round(mean(btw), 2), \"\\n\")\n\nLa intermediación promedio del grafo es de:  0.03 \n\n\nEn promedio, los países de la red no están ubicados entre las relaciones de conflicto de los demás países.\n\n# Centralidad propia \nev &lt;- igraph::eigen_centrality(g8)$vector\nhead(sort(ev, decreasing = T), n = 5)\n\n      IRQ       TUR       USA       IRN       GRC \n1.0000000 0.6101628 0.6036670 0.4512958 0.3660738 \n\n\nLos países que tienen relaciones de conflicto con más países centrales son IRAQ, TURQUIA y USA.\n\nresumen &lt;- rbind(resumen, round(mean(ev), 3))\ncat(\"La centralidad propia promedio del grafo es de: \", round(mean(ev), 2), \"\\n\")\n\nLa centralidad propia promedio del grafo es de:  0.08 \n\n\nEn promedio, los países no tienen relaciones de conflicto con países centrales.\nCohesión\n\n# Clan\ntable(sapply(X = cliques(graph = g8, min = 1, max = 10), FUN = length))\n\n\n  1   2   3   4 \n 91 160  67   9 \n\n\nEn la red hay 67 triadas que conforman un grafo completo y 9 cliques de tamaño 4.\n\n# Clanes máximos \nlargest_cliques(graph = g8)\n\n[[1]]\n+ 4/91 vertices, named, from 33866a5:\n[1] TUR IRQ JOR GRC\n\n[[2]]\n+ 4/91 vertices, named, from 33866a5:\n[1] TUR IRQ JOR SYR\n\n[[3]]\n+ 4/91 vertices, named, from 33866a5:\n[1] UGA RWA DRC ANG\n\n[[4]]\n+ 4/91 vertices, named, from 33866a5:\n[1] PRK CHN ROK JPN\n\n[[5]]\n+ 4/91 vertices, named, from 33866a5:\n[1] QAT IRQ SAU JOR\n\n[[6]]\n+ 4/91 vertices, named, from 33866a5:\n[1] USA IRQ JOR CAN\n\n[[7]]\n+ 4/91 vertices, named, from 33866a5:\n[1] USA IRQ JOR SYR\n\n[[8]]\n+ 4/91 vertices, named, from 33866a5:\n[1] SPN CAN JOR IRQ\n\n[[9]]\n+ 4/91 vertices, named, from 33866a5:\n[1] SYR IRQ JOR ISR\n\n\nHay 9 clanes máximos. Es posible observar que IRAQ está presente en la mayoría de estos.\n\n# Clan máximo \nclique_num(graph = g8)\n\n[1] 4\n\nresumen &lt;- rbind(resumen, clique_num(graph = g8))\ncat(\"El tamaño del clan máximo es de 4 países \\n\")\n\nEl tamaño del clan máximo es de 4 países \n\n\n\n# Densidad \ndens &lt;- edge_density(g8)\nresumen &lt;- rbind(resumen, round(dens, 3))\ncat(\"La densidad del grafo es de: \", round(dens,2))\n\nLa densidad del grafo es de:  0.04\n\n\nDado que la densidad de la red es de 0.04, la red está muy alejada de que todos los países tengan relaciones de conflicto con todos los demás.\n\n# Transitividad global\n# Número de triángulos por vértice\nhead(sort(count_triangles(graph = g8), decreasing = T), n = 5)\n\n[1] 37 33 10  7  7\n\n\nHay 2 países que están en más de 30 triangulos en la red.\n\ntr &lt;- transitivity(graph = g8, type = \"global\")\nresumen &lt;- rbind(resumen, round(tr, 3))\ncat(\"La transitividad del grafo es de: \", round(tr,2))\n\nLa transitividad del grafo es de:  0.16\n\n\nExiste baja propensión de que las triplas de la red de conflictos formen triángulos, pues la cuantificación del coeficiente de agrupamiento es de 0.16.\n\n# Transitividad local \nhead(sort(transitivity(graph = g8, type = \"local\"), decreasing = T), n = 15)\n\nAFG BAH CON HON ISR ITA MOR OMA PHI QAT ROK SAL SPN ZIM SYR \n1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 0.7 \n\n\nDe acuerdo a esto, hay al menos 10 países que tienen países vecinos propensos a ser clanes.\nConectividad\n\ncat(\"El grafo está conectado debilmente: \", is_connected(graph = g8, mode = \"weak\"), \"\\n\")\n\nEl grafo está conectado debilmente:  FALSE \n\n\nTodos los países no son accesibles desde todos los demás en esta red de conflictos.\n\n#k-conectividad\nvertex_connectivity(g8)\n\n[1] 0\n\n\nSi se remueve un vértice, el grafo restante no es conectado.\n\n# arista-conectividad\nedge_connectivity(g8)\n\n[1] 0\n\n\nSi se remueve una relación, el grafo restante no es conectado.\n\n# puntos de articulación\nhead(articulation_points(g8), n = 5)\n\n+ 5/91 vertices, named, from 33866a5:\n[1] USA GHA SIE NIG NIR\n\n\nSi se remueve algún país como USA o NIGERIA, el grafo queda desconectado.\n\ncomponentes &lt;- decompose(g8)\ncat(\"Hay \", length(componentes), \"componentes conectadas en el grafo \\n\")\n\nHay  5 componentes conectadas en el grafo \n\n\n\n# tamaño de la componte gigante\ntable(sapply(X = componentes, FUN = vcount))\n\n\n 2 83 \n 4  1 \n\n\nCuatro componentes tienen dos países y la componente gigante tiene 83.\n\nmax(sapply(X = componentes, FUN = vcount))/vcount(g8)\n\n[1] 0.9120879\n\n\nLa componente gigante tiene el 91 % de los países de la red.\n\n# componente gigante\ng8_gc &lt;- decompose(g8)[[1]]\n\n# vértice-conectividad\nvertex_connectivity(g8_gc)\n\n[1] 1\n\n# arista-conectividad\nedge_connectivity(g8_gc)\n\n[1] 1\n\n\nSe requiere la eliminación de un solo país o una sola relación para dividir el componente gigante en componentes adicionales.\n\n# puntos de articulación\ng8_cv &lt;- articulation_points(g8_gc)\nlength(g8_cv)\n\n[1] 22\n\n\nHay 22 países que hacen parte de la componente gigante, que al removerlos, desconectarían el grafo.\n\n# Proporcion nodos\nround(length(g8_cv)/vcount(g8_gc),2)\n\n[1] 0.27\n\n\nLo que corresponde al 27% de los países de la componente gigante.\nAgrupación\nSe prueban diferentes algoritmos para ser comparados con el método rand.\n# Algoritmos\nset.seed(1234)\nnc &lt;- layout_nicely(g8)\nE(g8)$color &lt;- \"gray\"\nigraph_options(vertex.size =18)\n\nkc_label_prop &lt;- cluster_label_prop(g8)\nplot(g8, vertex.label = NA, layout = nc, vertex.color = kc_label_prop$membership, main = paste0(\"label prop: \", \"Mod = \", round(modularity(kc_label_prop), 4)))\nkc_optimal &lt;- cluster_optimal(g8)\nplot(g8, vertex.label = NA, layout = nc, vertex.color = kc_optimal$membership, main = paste0(\"optimal: \", \"Mod = \", round(modularity(kc_optimal), 4)))\nkc_walktrap &lt;- cluster_walktrap(g8)\nplot(g8, vertex.label = NA, layout = nc, vertex.color = kc_walktrap$membership, main = paste0(\"walktrap: \", \"Mod = \", round(modularity(kc_walktrap), 4)))\nkc_louvain &lt;- cluster_louvain(g8)\nplot(g8, vertex.label = NA, layout = nc, vertex.color = kc_louvain$membership, main = paste0(\"louvain: \", \"Mod = \", round(modularity(kc_louvain), 4)))\nkc_infomap &lt;- cluster_infomap(g8)\nplot(g8, vertex.label = NA, layout = nc, vertex.color = kc_infomap$membership, main = paste0(\"infomap: \", \"Mod = \", round(modularity(kc_infomap), 4)))\nkc_edge &lt;- cluster_edge_betweenness(g8)\nplot(g8, vertex.label = NA, layout = nc, vertex.color = kc_edge$membership, main = paste0(\"edge betweennness: \", \"Mod = \", round(modularity(kc_edge), 4)))\nkc_fast_greedy &lt;- cluster_fast_greedy(g8)\nplot(g8, vertex.label = NA, layout = nc, vertex.color = kc_fast_greedy$membership, main = paste0(\"fast greedy: \", \"Mod = \", round(modularity(kc_fast_greedy), 4)))\nkc_leading_eigen &lt;- cluster_leading_eigen(g8)\nplot(g8, vertex.label = NA, layout = nc, vertex.color = kc_leading_eigen$membership, main = paste0(\"leading eigen: \", \"Mod = \", round(modularity(kc_leading_eigen), 4)))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# comparación usando el índice de rand\nalgoritmos &lt;- list(\n  fast_greedy = kc_fast_greedy$membership,\n  leading_eigen = kc_leading_eigen$membership,\n  walktrap = kc_walktrap$membership,\n  louvain = kc_louvain$membership,\n  label_prop = kc_label_prop$membership,\n  optimal = kc_optimal$membership,\n  infomap = kc_infomap$membership,\n  edge_betweenness = kc_edge$membership\n)\n\ncomp &lt;- expand.grid(\n  metodo1 = names(algoritmos),\n  metodo2 = names(algoritmos),\n  stringsAsFactors = FALSE\n)\n\n# Aplicar el Índice de Rand\ncomp$rand &lt;- mapply(function(m1, m2) {\n  compare(algoritmos[[m1]], algoritmos[[m2]], method = \"rand\")\n}, comp$metodo1, comp$metodo2)\n\n# Mostrar resultados como matriz\nmatriz &lt;- with(comp, tapply(rand, list(metodo1, metodo2), mean))\nkable(round(matriz, 3), align = \"c\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nedge_betweenness\nfast_greedy\ninfomap\nlabel_prop\nleading_eigen\nlouvain\noptimal\nwalktrap\n\n\n\n\nedge_betweenness\n1.000\n0.915\n0.905\n0.925\n0.877\n0.915\n0.918\n0.873\n\n\nfast_greedy\n0.915\n1.000\n0.956\n0.938\n0.874\n1.000\n0.996\n0.910\n\n\ninfomap\n0.905\n0.956\n1.000\n0.942\n0.869\n0.956\n0.955\n0.913\n\n\nlabel_prop\n0.925\n0.938\n0.942\n1.000\n0.873\n0.938\n0.938\n0.910\n\n\nleading_eigen\n0.877\n0.874\n0.869\n0.873\n1.000\n0.874\n0.876\n0.894\n\n\nlouvain\n0.915\n1.000\n0.956\n0.938\n0.874\n1.000\n0.996\n0.910\n\n\noptimal\n0.918\n0.996\n0.955\n0.938\n0.876\n0.996\n1.000\n0.913\n\n\nwalktrap\n0.873\n0.910\n0.913\n0.910\n0.894\n0.910\n0.913\n1.000\n\n\n\n\n\nDado que los índices de Rand entre las agrupaciones superan el 0.8, las particiones generadas por los algoritmos son bastante similares, lo que indica que las segmentaciones de nodos no presentan variaciones significativas entre ellos.\nResumen de medidas estructurales\n\nrownames(resumen) &lt;- c(\"Distancia media\", \"Grado medio\", \"Fuerza media\", \"Cercanía media\", \"Intermediación media\", \"Cercanía propia media\", \"Número clan\", \"Densidad\", \"Transitividad\")\nkable(resumen, align = \"c\")\n\n\n\n\n\nGrafo\n\n\n\n\nDistancia media\n5.072\n\n\nGrado medio\n3.516\n\n\nFuerza media\n6.700\n\n\nCercanía media\n0.260\n\n\nIntermediación media\n0.027\n\n\nCercanía propia media\n0.082\n\n\nNúmero clan\n4.000\n\n\nDensidad\n0.039\n\n\nTransitividad\n0.163",
    "crumbs": [
      "Talleres",
      "Taller 2"
    ]
  },
  {
    "objectID": "Taller2.html#punto-9",
    "href": "Taller2.html#punto-9",
    "title": "Taller 2",
    "section": "Punto 9",
    "text": "Punto 9\nSintetizar y replicar los Capítulos 6, 8, y 9 de Luke, D. A. (2015).\n\nCapítulo 6 - Graficos avanzados de redes\nAunque los paquetes statnet e igraph ofrecen funcionalidades avanzadas para la representación de redes, no siempre cumplen con todos los requerimientos analíticos o de presentación. En muchos casos, los investigadores en el campo de las redes necesitan visualizaciones más especializadas y dinámicas.\nGráficos Interactivos de Redes\nDiversos paquetes para el análisis de redes, como UCINet y Pajek, facilitan la creación de gráficos interactivos. Aunque R proporciona un control preciso sobre las visualizaciones, no siempre incluye funcionalidades interactivas de forma nativa. Por lo que se presentan alternativas para generar gráficos interactivos en R y publicarlos en la web.\nRedes interactivas simples con tkplot() en igraph\nEl paquete igraph incluye la función tkplot() para gráficos interactivos simples. Se usa para ajustar las posiciones de los nodos y luego producir un gráfico final no interactivo.\n\ndata(Bali)\niBali &lt;- asIgraph(Bali)\nCoord &lt;- tkplot(iBali, vertex.size=3,\n                vertex.label=V(iBali)$role,\n                vertex.color=\"darkgreen\")\n# Editar el gráfico en la ventana gráfica Tk antes\n# de ejecutar los siguientes dos comandos.\nMCoords &lt;- tk_coords(Coord)\nset.seed(1234)\nplot(iBali, layout=MCoords, vertex.size=5,\n     vertex.label=NA, vertex.color=\"lightblue\")\n\n\n\n\n\n\n\n\nPublicación de diagramas interactivos de redes basados en Web\nSe están implementando métodos para desarrollar gráficos interactivos basados en la web utilizando frameworks como D3.js y Shiny. El paquete networkD3 permite crear visualizaciones interactivas simples que pueden integrarse en documentos de Shiny o páginas HTML. Por otro lado, el paquete visNetwork, basado en la biblioteca vis.js, proporciona mayores posibilidades de personalización en la apariencia y facilita la incorporación de gráficos en aplicaciones web desarrolladas con Shiny.\nLa función simpleNetwork() espera los datos de la red en forma de una lista de aristas almacenada en un data.frame.\n\n#library(networkD3)\nsrc &lt;- c(\"A\", \"A\", \"B\", \"B\", \"C\", \"B\")\ntarget &lt;- c(\"B\", \"C\", \"C\", \"D\", \"B\", \"C\")\nnet_edge &lt;- data.frame(src, target)\nsimpleNetwork(net_edge)\n\n\n\n\n\nPara guardar la visualización:\n\nnet_D3 &lt;- simpleNetwork(net_edge)\n# saveNetwork(net_D3, file = 'Net_test1.html', selfcontained=TRUE)\n\nLa función forceNetwork() produce graficos más sofisticados.\nSe le deben pasar los datos en dos data.frames:\n\nEl data.frame de las aristas tendrá los datos de red en formato de matriz de aristas.\nEl data.frame de los nodos tendrá el ID de nodo y las propiedades de los nodos. Si los nodos tienen identificadores numéricos, deben comenzar en 0.\n\n\niBali_edge &lt;- as_edgelist(iBali)\niBali_edge &lt;- iBali_edge - 1\niBali_edge &lt;- data.frame(iBali_edge)\niBali_nodes &lt;- data.frame(NodeID=as.numeric(V(iBali)-1),\n                          Group=V(iBali)$role,\n                          Nodesize=igraph::degree(iBali))\nforceNetwork(Links = iBali_edge, Nodes = iBali_nodes,\n             Source = \"X1\", Target = \"X2\",\n             NodeID = \"NodeID\", Nodesize = \"Nodesize\",\n             radiusCalculation=\"Math.sqrt(d.nodesize)*3\",\n             Group = \"Group\", opacity = 0.8,\n             legend=TRUE)\n\n\n\n\n\nPara guardar el gráfico:\n\nnet_D3 &lt;- forceNetwork(Links = iBali_edge,\n                       Nodes = iBali_nodes,\n                       Source = \"X1\", Target = \"X2\",\n                       NodeID = \"NodeID\",Nodesize = \"Nodesize\",\n                       radiusCalculation=\"Math.sqrt(d.Nodesize)*3\",\n                       Group = \"Group\", opacity = 0.8,\n                       legend=TRUE)\n\n# saveNetwork(net_D3, file = 'Net_test2.html', selfcontained=TRUE)\n\nUsando la función vis.js de la libreria javascript.\nSe le deben pasar los datos en dos data.frames:\n\nEl data.frame de las aristas tendrá los datos de red en columnas from y to.\nEl data.frame de los nodos tendrá el ID de nodo y las propiedades de los nodos.\n\n\n#library(visNetwork)\niBali_edge &lt;- as_edgelist(iBali)\niBali_edge &lt;- data.frame(from = iBali_edge[,1],\n                         to = iBali_edge[,2])\niBali_nodes &lt;- data.frame(id = as.numeric(V(iBali)))\nset.seed(123)\nvisNetwork(iBali_nodes, iBali_edge, width = \"100%\")\n\n\n\n\n\nAlgunas opciones de la libreria son:\n\niBali_nodes$group &lt;- V(iBali)$role\niBali_nodes$value &lt;- igraph::degree(iBali)\nnet &lt;- visNetwork( iBali_nodes, iBali_edge,\n                  width = \"100%\", legend.width=TRUE)\nvisOptions(net, highlightNearest = TRUE)\n\n\n\n\n\nLas funciones visNetwork() y visOptions() establecen colores predeterminados para cada grupo y permiten que el usuario resalte los nodos individuales y sus vecinos inmediatos al hacer clic en un nodo.\nEn el ejemplo se agregan botones de navegación que permiten mover la red y acercar o alejar.\n\nnet &lt;- visNetwork(iBali_nodes, iBali_edge,\n                  width = \"100%\", legend=TRUE)\nnet &lt;- visOptions(net, highlightNearest = TRUE)\nnet &lt;- visInteraction(net, navigationButtons = TRUE)\n\n#library(htmlwidgets)\n#saveWidget(net, \"Net_test3.html\")\n\nStatnet Web: Statnet Interactivo con Shiny\nStatnet Web es una aplicación web, basada en las herramientas de análisis de redes de Statnet utilizando Shiny.\n\n#library(statnetWeb)\n#run_sw()\n\nDiagramas de redes especializados\nExisten técnicas especializadas para resaltar aspectos importantes de las redes, como diagramas de arco, diagramas de acordes y mapas de calor.\nDiagramas de Arco\nLos diagramas de arco se enfocan en el patrón de los enlaces más que en la posición de los nodos. Uso del paquete arcdiagram\n\n#library(devtools)\n#remotes::install_github(\"gastonstat/arcdiagram\")\n#library(arcdiagram)\n#library(UserNetR)\ndata(Simpsons)\niSimp &lt;- asIgraph(Simpsons)\nsimp_edge &lt;- get.edgelist(iSimp)\narcplot(simp_edge)\n\n\n\n\n\n\n\n\nAjustando colores por subgrupos y tamaño de los nodos de acuerdo al grado.\n\ns_grp &lt;- V(iSimp)$group\ns_col = c(\"#a6611a\", \"#dfc27d\", \"#80cdc1\", \"#018571\")\ncols = s_col[s_grp]\nnode_deg &lt;- igraph::degree(iSimp)\n\narcplot(simp_edge, lwd.arcs=2, cex.nodes=node_deg/2,\n        labels=V(iSimp)$vertex.names,\n        col.labels=\"darkgreen\", font=1,\n        pch.nodes=21, line=1, col.nodes = cols,\n        bg.nodes = cols, show.nodes = TRUE)\n\n\n\n\n\n\n\n\nDiagramas de Acordes\nLos diagramas de acordes usan un diseño circular para mostrar interrelaciones en una matriz. Son importantes para evaluar redes ponderadas y dirigidas.\nLos datos se deben tener en una sociomatriz, con las entradas correspondientes al tamaño del enlace y debe tener nombres asignados a filas y a columnas. El paquete circlize() implementa estos gráficos, permitiendo un gran control sobre la apariencia. Son útiles para redes valoradas y dirigidas.\n\n# library(statnet)\n# library(circlize)\ndata(FIFA_Nether)\nFIFAm &lt;- as.sociomatrix(FIFA_Nether, attrname='passes')\nnames &lt;- c(\"GK1\", \"DF3\", \"DF4\", \"DF5\", \"MF6\",\n           \"FW7\", \"FW9\", \"MF10\", \"FW11\", \"DF2\", \"MF8\")\nrownames(FIFAm) = names\ncolnames(FIFAm) = names\nFIFAm\n\n     GK1 DF3 DF4 DF5 MF6 FW7 FW9 MF10 FW11 DF2 MF8\nGK1    0  42  67  21   2  27   7    5    2  17   3\nDF3   30   0  44  14  42  15   8    7   10  36  29\nDF4   38  43   0  57  18  11   7   21    1   7  28\nDF5    6  14  47   0  11  50  20   40    1   4  42\nMF6    9  28  25  10   0  41  28   37   14  34  21\nFW7    4  12   1  21  21   0  15   33    9  25  18\nFW9    0   0   1   8   7  12   0   31   16   7   2\nMF10   1  11  11  22  43  29  20    0   28  13  21\nFW11   3   2   2   3   7   6  11   15    0  21  12\nDF2   29  38   8   3  45  38  10   18   26   0  15\nMF8   12  25  26  38  23  13  12   32   11  24   0\n\n\nEliminar los pases menores a 10 para hacer más facil de interpretar el gráfico.\n\nFIFAm[FIFAm &lt; 10 ] &lt;- 0\nFIFAm\n\n     GK1 DF3 DF4 DF5 MF6 FW7 FW9 MF10 FW11 DF2 MF8\nGK1    0  42  67  21   0  27   0    0    0  17   0\nDF3   30   0  44  14  42  15   0    0   10  36  29\nDF4   38  43   0  57  18  11   0   21    0   0  28\nDF5    0  14  47   0  11  50  20   40    0   0  42\nMF6    0  28  25  10   0  41  28   37   14  34  21\nFW7    0  12   0  21  21   0  15   33    0  25  18\nFW9    0   0   0   0   0  12   0   31   16   0   0\nMF10   0  11  11  22  43  29  20    0   28  13  21\nFW11   0   0   0   0   0   0  11   15    0  21  12\nDF2   29  38   0   0  45  38  10   18   26   0  15\nMF8   12  25  26  38  23  13  12   32   11  24   0\n\n\n\nset.seed(123)\nchordDiagram(FIFAm)\n\n\n\n\n\n\n\n\nAjuste de parámetros:\n\nJugadores en la misma posición van a tener el mismo color.\nComo la red es dirigida, los pases de salida comienzan más lejos del círculo exterior, lo que facilita ver la diferencia entre los pases enviados y los pases recibidos.\nOrdenar a los jugadores por su posición.\n\n\nset.seed(123)\ngrid.col &lt;- c(\"#AA3939\",rep(\"#AA6C39\",4), rep(\"#2D882D\",3),rep(\"#226666\",3))\n\nchordDiagram(FIFAm,directional = TRUE, grid.col = grid.col, order=c(\"GK1\",\"DF2\",\"DF3\",\"DF4\",\"DF5\", \"MF6\",\"MF8\",\"MF10\",\"FW7\", \"FW9\",\"FW11\"))\n\n\n\n\n\n\n\n\nMapas de calor\nLos mapas de calor resaltan nodos con mayor cantidad de conexiones en redes ponderadas. Se debe crear una sociomatriz que refleje el peso y se debem definir los nombres de filas y columnas.\n\ndata(FIFA_Nether)\nFIFAm &lt;- as.sociomatrix(FIFA_Nether, attrname='passes')\ncolnames(FIFAm) &lt;- c(\"GK1\", \"DF3\", \"DF4\", \"DF5\", \"MF6\", \"FW7\", \"FW9\", \"MF10\", \"FW11\", \"DF2\", \"MF8\")\nrownames(FIFAm) &lt;- c(\"GK1\", \"DF3\", \"DF4\", \"DF5\", \"MF6\", \"FW7\", \"FW9\", \"MF10\", \"FW11\", \"DF2\", \"MF8\")\n\n\npal &lt;- colorRampPalette(c(\"#669999\", \"#003333\"))\nheatmap(FIFAm[,11:1], Rowv = NA, Colv = NA, col = pal(60), scale = \"none\")\n\n\n\n\n\n\n\n\nCreación de diagramas con otros paquetes de R\nGgplot2\nAunque ggplot2 no es un paquete completo de visualización de redes, sus capacidades gráficas avanzadas permiten crear gráficos especializados de redes dirigidas, haciendo relaciones curvos entre cada díada conectada.\n\nedgeMaker &lt;- function(whichRow, len=100, curved = TRUE){\n  fromC &lt;- layoutCoordinates[adjacencyList[whichRow, 1],]\n  toC &lt;- layoutCoordinates[adjacencyList[whichRow, 2], ]\n  graphCenter &lt;- colMeans(layoutCoordinates)\n  bezierMid &lt;- c(fromC[1], toC[2])\n  distance1 &lt;- sum((graphCenter - bezierMid)^2)\n  if(distance1 &lt; sum((graphCenter - c(toC[1], fromC[2]))^2)){\n    bezierMid &lt;- c(toC[1], fromC[2])\n  }\n  bezierMid &lt;- (fromC + toC + bezierMid) / 3\n  if(curved == FALSE){bezierMid &lt;- (fromC + toC) / 2}\n  \n  edge &lt;- data.frame(Hmisc::bezier(c(fromC[1], bezierMid[1], toC[1]),\n                            c(fromC[2], bezierMid[2], toC[2]),\n                            evaluation = len))\n  edge$Sequence &lt;- 1:len\n  edge$Group &lt;- paste(adjacencyList[whichRow, 1:2], collapse = \"-\")\n  return(edge)\n}\n\nFunción bezier() del paquete Hmisc\n\n# library(sna)\n# library(ggplot2)\n# library(Hmisc)\n\nSe deben transformar los datos a un formato de matriz de aristas y se eliminan pases menores a 10.\n\ndata(FIFA_Nether)\nfifa &lt;- FIFA_Nether\nfifa.edge &lt;- as.edgelist.sna(fifa, attrname='passes')\nfifa.edge &lt;- data.frame(fifa.edge)\nnames(fifa.edge)[3] &lt;- 'Value'\nfifa.edge &lt;- fifa.edge[fifa.edge$Value &gt; 9, ]\nadjacencyList &lt;- fifa.edge\n\nSe usa la función gplot para almacenar las coordenadas de diseño para la función ggplot2.\n\nlayoutCoordinates &lt;- gplot(network(fifa.edge))\n\n\n\n\n\n\n\nallEdges &lt;- lapply(1:nrow(fifa.edge), edgeMaker, len = 500, curved = TRUE)\nallEdges &lt;- do.call(rbind, allEdges)\n\n\nnew_theme_empty &lt;- theme_bw()\nnew_theme_empty$line &lt;- element_blank()\nnew_theme_empty$rect &lt;- element_blank()\nnew_theme_empty$strip.text &lt;- element_blank()\nnew_theme_empty$axis.text &lt;- element_blank()\nnew_theme_empty$plot.title &lt;- element_blank()\nnew_theme_empty$axis.title &lt;- element_blank()\nnew_theme_empty$plot.margin &lt;- structure(c(0, 0, -1, -1), \n  unit = \"lines\", valid.unit = 3L, class = \"unit\")\n\nFunción ggplot.\nLa opción scale_colour_gradient controla la intensidad del degradado y la opción scale_size controla la cantidad de conicidad.\n\nset.seed(123)\nzpl &lt;- ggplot(allEdges)\nzpl &lt;- zpl + geom_path(aes(x = x, y = y, group = Group, colour = Sequence, size = -Sequence))\nzpl &lt;- zpl + geom_point(data = data.frame(layoutCoordinates), aes(x = x, y = y), size = 4, pch = 21, colour = \"black\", fill = \"gray\")\nzpl &lt;- zpl + scale_colour_gradient(low = gray(0), high = gray(9/10), guide = \"none\")\nzpl &lt;- zpl + scale_size(range = c(1/10, 1.5), guide = \"none\")\nzpl &lt;- zpl + new_theme_empty\nprint(zpl)\n\n\n\n\n\n\n\n\n\n\nCapítulo 8 - Subgrupos\nMuchas redes sociales del mundo real pueden dividirse en subgrupos de redes densamente conectadas a través de una menor cantidad de aristas, lo que va a ser de gran importancia identificar si se quiere de descubrir el comportamiento de toda la red.\nCohesión social: La cohesión social permite identificar subgrupos de individuos con enlaces fuertes y directos.\nCliques: Un clique es un subgrafo maximamente completo, es decir un subgrafo donde cada vértice puede acceder a los demás a través de una relación directa.\nEjemplo 1.\n\nclqexmp &lt;- graph_from_literal(A:B:C:D--A:B:C:D,D-E,E-F-G-E)\nset.seed(123)\nplot(clqexmp, vertex.color = \"lightblue\")\n\n\n\n\n\n\n\n\nEste grafo tiene dos cliques, A, B, C, D y E, F, G. Los cliques relevantes van a ser los de orden igual o superior a 3. Por definición, un clique de orden \\(k\\) también contiene cliques de orden \\(k-1\\), \\(k-2\\), etc.\nLa función clique_num() muestra el orden del clique más grande.\n\nclique_num(clqexmp)\n\n[1] 4\n\n\nLa función cliques() retorna una lista de los cliques de un orden mínimo y máximo asignado.\n\ncliques(clqexmp,min=3)\n\n[[1]]\n+ 3/7 vertices, named, from 4e6f730:\n[1] B C D\n\n[[2]]\n+ 3/7 vertices, named, from 4e6f730:\n[1] E F G\n\n[[3]]\n+ 3/7 vertices, named, from 4e6f730:\n[1] A B C\n\n[[4]]\n+ 4/7 vertices, named, from 4e6f730:\n[1] A B C D\n\n[[5]]\n+ 3/7 vertices, named, from 4e6f730:\n[1] A B D\n\n[[6]]\n+ 3/7 vertices, named, from 4e6f730:\n[1] A C D\n\n\nLa función max_cliques() es útil cuando hay muchos cliques, pues omite los cliques que hacen parte de cliques de orden mayor.\n\nmax_cliques(clqexmp,min=3)\n\n[[1]]\n+ 3/7 vertices, named, from 4e6f730:\n[1] E F G\n\n[[2]]\n+ 4/7 vertices, named, from 4e6f730:\n[1] A B D C\n\n\nLa función largest_cliques() identifica el clique de orden mayor.\n\nlargest_cliques(clqexmp)\n\n[[1]]\n+ 4/7 vertices, named, from 4e6f730:\n[1] A B D C\n\n\nLa siguiente linea de código muestra como se puede obtener el nombre de los vértices, en lugar de sus id’s (como lo hacen las funciones anteriores).\n\nV(clqexmp)[unlist(largest_cliques(clqexmp))]\n\n+ 4/7 vertices, named, from 4e6f730:\n[1] A B D C\n\n\nDesventajas de los cliques:\n\nEs una definición conservadora de un subgrupo cohesivo, pues requiere que cada vertice este relacionado con todos los demás, lo que podría descartar subgrupos realmente cohesivos por falta de unos pocos enlaces.\nDada su anterior limitación, en redes grandes del mundo real, los cliques no son comunes.\n\nLa siguiente simulación muestra lo poco comunes que son los cliques. Se simularon 4 redes con 25, 50, 100 y 500 nodos. Para cada red, el promedio del grado es como máximo 6. La tabla muestra que el número de cliques se mantiene constante a pesar de que el orden de la red aumenta. Además, los cliques son de tamaño pequeño en todos los casos.\n\nset.seed(9679)\ng25 &lt;- erdos.renyi.game(25, 75, type=\"gnm\")\ng50 &lt;- erdos.renyi.game(50, 150, type=\"gnm\")\ng100 &lt;- erdos.renyi.game(100, 300, type=\"gnm\")\ng500 &lt;- erdos.renyi.game(500, 1500, type=\"gnm\")\nnodes &lt;- c(25,50,100,500)\nlrgclq &lt;- c(clique_num(g25),clique_num(g50), clique_num(g100),clique_num(g500))\nnumclq &lt;- c(length(cliques(g25,min=3)),length(cliques(g50,min=3)),\n            length(cliques (g100,min=3)),length(cliques(g500,min=3)))\nclqinfo &lt;- data.frame (Nodes=nodes,Largest=lrgclq,\nNumber=numclq)\nclqinfo\n\n  Nodes Largest Number\n1    25       4     34\n2    50       3     36\n3   100       3     36\n4   500       3     38\n\n#kable(clqinfo, align = \"c\")\n\nk-cores\nEs una variación de la idea de los cliques. Un k-core es un subgrafo maximal donde cada vertice está conectado con al menos k vertices. Una de las ventajas del k-core es que es anidado, es decir cada miembro de un 4-core es miembro de un 3-core y así sucesivamente.\nEjemplo DHHS\n\n# library(statnet)\n# install.packages(\"remotes\")\n# remotes::install_github(\"DougLuke/UserNetR\")\n# library(UserNetR)\n# data(DHHS)\n# library(intergraph)\niDHHS &lt;- asIgraph(DHHS)\nedge_density(iDHHS)\n\n[1] 0.312369\n\n\nLa función subgraph.edges() selecciona solo las aristas con atributos 3 o 4.\n\niDHHS&lt;-subgraph_from_edges(iDHHS,E(iDHHS)[collab&gt;2])\nedge_density(iDHHS)\n\n[1] 0.1533688\n\n\nLa función graph.coreness() identifica la estructura k-core\n\ncoreness&lt;-coreness(iDHHS)\ntable(coreness)\n\ncoreness\n 1  2  3  4  5  6 \n 7  6  2  5  2 26 \n\nmaxCoreness&lt;-max(coreness)\nmaxCoreness\n\n[1] 6\n\n\nGrafica de la red teniendo en cuenta la estrcutura k-core\n\n# Vname &lt;- get.vertex.attribute(iDHHS, name= 'vertex.names',index=V(iDHHS))\n# V(iDHHS)$name&lt;-Vname\nV(iDHHS)$color&lt;-coreness+1\nop &lt;-par(mar=rep(0,4))\nset.seed(123)\nplot(iDHHS,vertex.label.cex=0.8)\n\n\n\n\n\n\n\npar(op)\n\nAgregar labels que indiquen el valor k-core\n\ncolors &lt;-rainbow(maxCoreness)\nop &lt;-par(mar=rep(0,4))\nplot(iDHHS,vertex.label=coreness,vertex.color=colors[coreness])\n\n\n\n\n\n\n\npar(op)\n\nEl centro de la red está compuesta principalmente por los k-core más altos.\nPara examinar los patrones de cada subgrupo, se van a ir despegando los k-cores del más bajo al más alto con la función induced.subgraph()\n\nV(iDHHS)$name &lt;- coreness\nV(iDHHS)$color &lt;- colors[coreness]\niDHHS1_6 &lt;- iDHHS\niDHHS2_6 &lt;- induced_subgraph(iDHHS, vids= which(coreness &gt; 1))\niDHHS3_6 &lt;- induced_subgraph(iDHHS,vids = which(coreness &gt; 2))\niDHHS4_6 &lt;- induced_subgraph(iDHHS,vids = which(coreness &gt; 3))\niDHHS5_6 &lt;- induced_subgraph(iDHHS,vids = which(coreness &gt; 4))\niDHHS6_6 &lt;- induced_subgraph(iDHHS,vids = which(coreness &gt; 5))\n\nlay &lt;- layout.fruchterman.reingold(iDHHS)\nop &lt;- par (mfrow=c(3,2),mar = c(3,0,2,0))\nset.seed(123)\nplot (iDHHS1_6,layout=lay,main=\"All k-cores\")\nplot (iDHHS2_6,layout=lay[which(coreness &gt; 1),],main=\"k-cores 2-6\")\nplot (iDHHS3_6,layout=lay[which (coreness &gt; 2),],main=\"k-cores 3-6\")\nplot (iDHHS4_6,layout=lay [which (coreness &gt; 3),],main=\"k-cores 4-6\")\nplot (iDHHS5_6,layout=lay[which (coreness &gt; 4),],main=\"k-cores 5-6\")\nplot (iDHHS6_6,layout=lay[which(coreness &gt; 5),],main=\"k-cores 6-6\")\n\n\n\n\n\n\n\npar(op)\n\nDetección comunitaria\nTanto k-cores como cliques son ejemplos que para identificar subgrupos dependen del patron de relaciones internas definidas en estos. Sin embargo, existen algoritmos de identificación de subgrupos que detectan grupos de tal manera que hayan muchas relaciones internas y algunas entre otros grupos.\nModularidad\nEs una medida del grado en que los nodos presentan agrupamiento, donde hay mayor densidad dentro de los grupos y menos densidad entre ellos.\n\nPuede ser usada para que un algoritmo intente maximizarla y devuelva la mejor clasificación que explique a la red.\nPuede ser usada como estadística para cualquier variable de clasificación de nodos.\n\nLa modularidad puede variar desde \\(\\frac{-1}{2}\\) a \\(1\\). Entre más cerca de 1, más agrupación exhibe la red con respecto a la variable de agrupamiento dada.\nEjemplo: Red de 9 nodos con dos atributos que clasifican los nodos en tres grupos.\n\ng1 &lt;- graph_from_literal(A-B-C-A,D-E-F-D,G-H-I-G,A-D-G-A)\nV(g1)$grp_good &lt;- c(1,1,1,2,2,2,3,3,3)\nV(g1)$grp_bad &lt;- c(1,2,3,2,3,1,3,1,2)\nset.seed(123)\nop &lt;- par(mfrow=c(1,2))\nplot(g1,vertex.color =(V(g1)$grp_good),vertex.size=20,  main=\"Good Grouping\")\nplot(g1,vertex.color=(V(g1)$grp_bad),vertex.size=20,main=\"Bad Grouping\")\n\n\n\n\n\n\n\npar(op)\n\nLa agrupación que mejor explica a la red es la de la izquierda, lo que se puede comprobar calculando la modularidad.\n\nmodularity(g1,V(g1)$grp_good)\n\n[1] 0.4166667\n\nmodularity(g1,V(g1)$grp_bad)\n\n[1] -0.3333333\n\n\nEjemplo DHHS\n\nlibrary(intergraph)\ndata(DHHS)\niDHHS &lt;- asIgraph(DHHS)\ntable(V(iDHHS)$agency)\n\n\n 0  1  2  3  4  5  6  7  8  9 10 \n 2  4 12  2  2  3  2 16  3  5  3 \n\nV(iDHHS)[1:10]\n\n+ 10/54 vertices, from 519d8a0:\n [1]  1  2  3  4  5  6  7  8  9 10\n\nmodularity(iDHHS,(V(iDHHS)$agency+1))\n\n[1] 0.1402264\n\n\nComo la modularidad es de 0.14, entonces la variable agency explica algo del agrupamiento presente en la red.\nLa modularidad adquiere un significado más útil si se utiliza para compararse con otra medida relevante. Por ejemplo, comparar la estadística usando dos variables nodales distintas.\nEjemplo Moreno\n\ndata(Moreno)\niMoreno &lt;- asIgraph(Moreno)\ntable(V(iMoreno)$gender)\n\n\n 1  2 \n16 17 \n\nmodularity(iMoreno,V(iMoreno)$gender)\n\n[1] 0.4761342\n\ndata(Facebook)\nFacebook &lt;- upgrade_graph(Facebook)\nlevels(factor(V(Facebook)$group))\n\n[1] \"B\" \"C\" \"F\" \"G\" \"H\" \"M\" \"S\" \"W\"\n\ngrp_num &lt;- as.numeric(factor(V(Facebook)$group))\nmodularity(Facebook,grp_num)\n\n[1] 0.6145798\n\n\nAlgoritmos de detección de comunidades\nCorrer una de las funciones de igraph() que contiene un algoritmo para detección de comunidades:\n\ncw &lt;- cluster_walktrap(iMoreno)\nmembership(cw)\n\n [1] 1 1 1 1 1 1 1 1 3 3 3 5 5 5 5 1 3 2 2 2 4 4 4 2 2 2 2 2 2 2 2 6 6\n\nmodularity(cw)\n\n[1] 0.6181474\n\n\nSe identificaron 6 grupos:\n\nset.seed(1234)\nplot(cw, iMoreno)\n\n\n\n\n\n\n\n\nSe puede comparar esta partición generada con alguna partición existente basada en una variable nodal.\nEjemplo DHHS\n\ncw &lt;- cluster_walktrap(iDHHS)\nmodularity(cw)\n\n[1] 0.1653754\n\nmembership(cw)\n\n [1] 4 5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 3 3 3 3 3 3 3 3 3 3\n[39] 3 3 3 3 3 2 2 2 2 1 2 1 1 1 1 1\n\ntable(V(iDHHS)$agency,membership(cw))\n\n    \n      1  2  3  4  5\n  0   0  0  0  1  1\n  1   4  0  0  0  0\n  2  12  0  0  0  0\n  3   2  0  0  0  0\n  4   2  0  0  0  0\n  5   3  0  0  0  0\n  6   2  0  0  0  0\n  7   0  0 16  0  0\n  8   0  3  0  0  0\n  9   3  2  0  0  0\n  10  3  0  0  0  0\n\n\nSe pueden comparar distintas particiones generadas por algoritmos distintos.\n\ndata(Bali)\niBali &lt;- asIgraph(Bali)\n\ncw &lt;- cluster_walktrap(iBali)\nmodularity(cw)\n\n[1] 0.2830688\n\nmembership(cw)\n\n [1] 2 1 2 1 2 2 1 2 2 3 3 3 3 3 2 2 2\n\nceb &lt;- cluster_edge_betweenness(iBali)\nmodularity(ceb)\n\n[1] 0.2387251\n\nmembership(ceb)\n\n [1] 1 1 1 1 1 1 1 1 1 2 2 2 2 2 1 1 1\n\ncs &lt;- cluster_spinglass(iBali)\nmodularity(cs)\n\n[1] 0.2966742\n\nmembership(cs)\n\n [1] 3 2 3 1 3 3 2 3 3 1 1 1 1 1 3 3 3\n\ncfg &lt;- cluster_fast_greedy(iBali)\nmodularity(cfg)\n\n[1] 0.2629126\n\nmembership(cfg)\n\n [1] 2 2 1 2 1 2 2 1 1 3 3 3 3 3 1 1 1\n\nclp &lt;- cluster_label_prop(iBali)\nmodularity(clp)\n\n[1] 0.2387251\n\nmembership(clp)\n\n [1] 1 1 1 1 1 1 1 1 1 2 2 2 2 2 1 1 1\n\ncle &lt;- cluster_leading_eigen(iBali)\nmodularity(cle)\n\n[1] 0.2750063\n\nmembership(cle)\n\n [1] 1 1 1 2 1 1 2 1 1 2 2 2 2 2 1 1 1\n\ncl &lt;- cluster_louvain(iBali)\nmodularity(cl)\n\n[1] 0.2966742\n\nmembership(cl)\n\n [1] 1 2 1 3 1 1 2 1 1 3 3 3 3 3 1 1 1\n\nco &lt;- cluster_optimal(iBali)\nmodularity(co)\n\n[1] 0.2966742\n\nmembership(co)\n\n [1] 1 2 1 3 1 1 2 1 1 3 3 3 3 3 1 1 1\n\n\nTodos los algoritmos identificaron 2 o 3 grupos y el rango de la modularidad fue de 0.24 a 0.30.\nLos resultados de la detección de los grupos se pueden comparar utilizando métricas de comparación de clasificación, por ejemplo la estadística Rand ajustada.\n\ntable(V(iBali)$role,membership(cw))\n\n    \n     1 2 3\n  BM 0 5 0\n  CT 1 2 0\n  OA 2 1 0\n  SB 0 1 1\n  TL 0 0 4\n\ncompare(as.numeric(factor(V(iBali)$role)),cw,method=\"adjusted.rand\")\n\n[1] 0.3504908\n\ncompare(cw,ceb,method=\"adjusted.rand\")\n\n[1] 0.6155779\n\ncompare(cw,cs,method=\"adjusted.rand\")\n\n[1] 0.8898148\n\ncompare(cw,cfg,method=\"adjusted.rand\")\n\n[1] 0.6691802\n\n\nGraficos de resultados de la detección grupos con diferentes algoritmos\n\nset.seed(123)\nop &lt;-par(mfrow=c(3,2),mar=c(3,0,2,0))\nplot(ceb, iBali,vertex.label=V(iBali)$role,main=\"Edge Betweenness\")\nplot(cfg, iBali,vertex.label=V(iBali)$role,main=\"Fastgreedy\")\nplot(clp, iBali,vertex.label=V(iBali)$role,main=\"Label Propagation\")\nplot(cle, iBali,vertex.label=V(iBali)$role,main=\"Leading Eigenvector\")\nplot(cs, iBali,vertex.label=V(iBali)$role,main=\"Spinglass\")\nplot(cw, iBali,vertex.label=V(iBali)$role,main=\"Walktrap\")\n\n\n\n\n\n\n\npar(op)\n\n\n\nCapítulo 9 - Redes de afiliación\nUna red de afiliación es aquella donde los miembros están conectados por su co-pertenencia a un grupo o por su co-participación en algún evento. Por ejemplo, estudiantes que pertenecen a la misma clase pueden considerarse conectados, aunque no sepamos si tienen vínculos sociales directos.\nEjemplo - estudiantes\n\nC1 &lt;- c(1,1,1,0,0,0)\nC2 &lt;- c(0,1,1,1,0,0)\nC3 &lt;- c(0,0,1,1,1,0)\nC4 &lt;- c(0,0,0,0,1,1)\naff.df &lt;- data.frame(C1,C2,C3,C4)\nrow.names(aff.df) &lt;- c(\"S1\",\"S2\",\"S3\",\"S4\",\"S5\",\"S6\")\nkable(aff.df, align = \"c\")\n\n\n\n\n\nC1\nC2\nC3\nC4\n\n\n\n\nS1\n1\n0\n0\n0\n\n\nS2\n1\n1\n0\n0\n\n\nS3\n1\n1\n1\n0\n\n\nS4\n0\n1\n1\n0\n\n\nS5\n0\n0\n1\n1\n\n\nS6\n0\n0\n0\n1\n\n\n\n\n\nEsta es una matriz de incidencia, que indica si un estudiante s pertenece a un grupo g. A diferencia de una matriz de adyacencia, la matriz de incidencia no es cuadrada.\nGrafos bipartitos En redes de afiliación hay dos tipos de nodos: actores (individuos) y grupos (a los que pertenecen los actores). Las relaciones solo conectan actores con grupos, pero no hay conexiones directas entre actores ni entre grupos.\n\nbn &lt;-graph_from_biadjacency_matrix(aff.df)\nplt.x &lt;-c(rep(2,6),rep(4,4))\nplt.y &lt;-c(7:2,6:3)\nlay &lt;-as.matrix(cbind(plt.x,plt.y))\n\nshapes &lt;-c(\"circle\",\"square\")\ncolors &lt;-c(\"blue\",\"red\")\nplot(bn,vertex.color=colors[V(bn)$type+1],\n     vertex.shape=shapes[V(bn)$type+1],\n     vertex.size=10,vertex.label.degree=-pi/2,\n     vertex.label.dist=1.2,vertex.label.cex=0.9,\n     layout=lay)\n\n\n\n\n\n\n\n\nConceptos básicos\nCreación de redes de afiliación a partir de matrices de incidencia\nEn igraph, los grafos bipartitos se crean a partir de matrices de incidencia y, en este caso, las filas se leen como actores y las columnas como grupos o eventos. Además, se tienen dos atributos de vértice: - Nombre del vértice. - Tipo de nodo: type = FALSE para actores o type = TRUE para grupos o eventos.\n\nas_biadjacency_matrix(bn)\n\n   C1 C2 C3 C4\nS1  1  0  0  0\nS2  1  1  0  0\nS3  1  1  1  0\nS4  0  1  1  0\nS5  0  0  1  1\nS6  0  0  0  1\n\nV(bn)$type\n\n [1] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n\nV(bn)$name\n\n [1] \"S1\" \"S2\" \"S3\" \"S4\" \"S5\" \"S6\" \"C1\" \"C2\" \"C3\" \"C4\"\n\n\nCreación de redes de afiliación a partir de listas de relaciones\nEs común construir redes usando listas de relaciones.\n\nel.df &lt;- data.frame(rbind(c(\"S1\",\"C1\"),\n                          c(\"S2\",\"C1\"),\n                          c(\"S2\",\"C2\"),\n                          c(\"S3\",\"C1\"),\n                          c(\"S3\",\"C2\"),\n                          c(\"S3\",\"C3\"),\n                          c(\"S4\",\"C2\"),\n                          c(\"S4\",\"C3\"),\n                          c(\"S5\",\"C3\"),\n                          c(\"S5\",\"C4\"),\n                          c(\"S6\",\"C4\")))\n\nbn2 &lt;- graph_from_data_frame(el.df,directed=FALSE)\nbn2\n\nIGRAPH 55d96fb UN-- 10 11 -- \n+ attr: name (v/c)\n+ edges from 55d96fb (vertex names):\n [1] S1--C1 S2--C1 S2--C2 S3--C1 S3--C2 S3--C3 S4--C2 S4--C3 S5--C3 S5--C4\n[11] S6--C4\n\n\nSin embargo, el objeto creado no se reconoce como bipartito. Para corregirlo, es necesario especificar manualmente el atributo type.\n\nV(bn2)$type &lt;-V(bn2)$name %in% el.df[,1]\nbn2\n\nIGRAPH 55d96fb UN-B 10 11 -- \n+ attr: name (v/c), type (v/l)\n+ edges from 55d96fb (vertex names):\n [1] S1--C1 S2--C1 S2--C2 S3--C1 S3--C2 S3--C3 S4--C2 S4--C3 S5--C3 S5--C4\n[11] S6--C4\n\nedge_density(bn)==edge_density(bn2)\n\n[1] TRUE\n\n\nVisualización de redes de afiliación\nPara visualizar redes de afiliación es útil usar formas y colores que diferencien actores de grupos.\n\nshapes &lt;-c(\"circle\",\"square\")\ncolors &lt;-c(\"blue\",\"red\")\nset.seed(123)\nplot(bn,vertex.color=colors[V(bn)$type+1],\n     vertex.shape=shapes[V(bn)$type+1],\n     vertex.size=10,vertex.label.degree=-pi/2,\n     vertex.label.dist=1.2,vertex.label.cex=0.9)\n\n\n\n\n\n\n\n\nProyecciones\nEn una red de afiliación, los nodos de cada grupo pueden estar conectados indirectamente a partir de las conexiones entre grupos. Por ejemplo: la clase C3 y C4 están conectadas a través del estudiante S5.\nPara analizar conexiones directas, se crean proyecciones que transforman la red en una estructura con un único tipo de nodo, así, os actores se vinculan entre ellos cuando forman parte del mismo grupo y los grupos se enlazan entre sí cuando comparten actores en común.\n\nbn.pr &lt;- bipartite_projection(bn)\nbn.pr\n\n$proj1\nIGRAPH 5651843 UNW- 6 8 -- \n+ attr: name (v/c), weight (e/n)\n+ edges from 5651843 (vertex names):\n[1] S1--S2 S1--S3 S2--S3 S2--S4 S3--S4 S3--S5 S4--S5 S5--S6\n\n$proj2\nIGRAPH 565187d UNW- 4 4 -- \n+ attr: name (v/c), weight (e/n)\n+ edges from 565187d (vertex names):\n[1] C1--C2 C1--C3 C2--C3 C3--C4\n\n\nCada lista puede ser tratada como un objeto igraph cualquiera.\n\ngraph.density(bn.pr$proj1)\n\nWarning: `graph.density()` was deprecated in igraph 2.0.0.\nℹ Please use `edge_density()` instead.\n\n\n[1] 0.5333333\n\nbn.student &lt;-bn.pr$proj1\nbn.class &lt;-bn.pr$proj2\ngraph.density(bn.student)\n\n[1] 0.5333333\n\n\nObtención de las matrices de adyacencia con pesos:\n\nas_adjacency_matrix(bn.student,sparse=FALSE,attr=\"weight\")\n\n   S1 S2 S3 S4 S5 S6\nS1  0  1  1  0  0  0\nS2  1  0  2  1  0  0\nS3  1  2  0  2  1  0\nS4  0  1  2  0  1  0\nS5  0  0  1  1  0  1\nS6  0  0  0  0  1  0\n\nas_adjacency_matrix(bn.class,sparse=FALSE,attr=\"weight\")\n\n   C1 C2 C3 C4\nC1  0  2  1  0\nC2  2  0  2  0\nC3  1  2  0  1\nC4  0  0  1  0\n\n\n\nshapes &lt;-c(\"circle\",\"square\")\ncolors &lt;-c(\"blue\",\"red\")\nop &lt;-par(mfrow=c(1,2))\nplot(bn.student,vertex.color=\"blue\",\n     vertex.shape=\"circle\",main=\"Students\",\n     edge.width=E(bn.student)$weight*2,\n     vertex.size=15,vertex.label.degree=-pi/2,\n     vertex.label.dist=1.2,vertex.label.cex=1)\nplot(bn.class,vertex.color=\"red\",\n     vertex.shape=\"square\",main=\"Classes\",\n     edge.width=E(bn.student)$weight*2,\n     vertex.size=15,vertex.label.degree=-pi/2,\n     vertex.label.dist=1.2,vertex.label.cex=1)\n\n\n\n\n\n\n\npar(op)\n\nEjemplo - actores de Hollywood\nEl dataset hwd del paquete UseNetR contiene una red de afiliación de actores de Hollywood conectados a través de películas. El conjunto de datos incluye a las diez películas más populares (según usuarios de IMDb) de cada año desde 1999 hasta 2014, los diez primeros actores listados en IMDb para cada película, los nombres de películas y actores y cada película incluye el año de lanzamiento, la calificación de usuarios de IMDb y la clasificación de películas según la MPAA.\nAnálisis de la red\n\ndata(hwd)\nh1 &lt;- igraph::upgrade_graph(hwd)\nh1\n\nIGRAPH 9cdab39 UN-B 1365 1600 -- \n+ attr: name (v/c), type (v/l), year (v/n), IMDBrating (v/n),\n| MPAArating (v/c)\n+ edges from 9cdab39 (vertex names):\n [1] Inception          --Leonardo DiCaprio   \n [2] Inception          --Joseph Gordon-Levitt\n [3] Inception          --Ellen Page          \n [4] Inception          --Tom Hardy           \n [5] Inception          --Ken Watanabe        \n [6] Inception          --Dileep Rao          \n [7] Inception          --Cillian Murphy      \n+ ... omitted several edges\n\nV(h1)$name[1:10]\n\n [1] \"Inception\"                                   \n [2] \"Alice in Wonderland\"                         \n [3] \"Kick-Ass\"                                    \n [4] \"Toy Story 3\"                                 \n [5] \"How to Train Your Dragon\"                    \n [6] \"Despicable Me\"                               \n [7] \"Scott Pilgrim vs. the World\"                 \n [8] \"Hot Tub Time Machine\"                        \n [9] \"Harry Potter and the Deathly Hallows: Part 1\"\n[10] \"Tangled\"                                     \n\nV(h1)$type[1:10]\n\n [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n\nV(h1)$IMDBrating[1:10]\n\n [1] 8.8 6.5 7.8 8.4 8.2 7.7 7.5 6.5 7.7 7.9\n\nV(h1)$name[155:165]\n\n [1] \"Notting Hill\"               \"Eyes Wide Shut\"            \n [3] \"The Green Mile\"             \"10 Things I Hate About You\"\n [5] \"American Pie\"               \"Girl, Interrupted\"         \n [7] \"Leonardo DiCaprio\"          \"Joseph Gordon-Levitt\"      \n [9] \"Ellen Page\"                 \"Tom Hardy\"                 \n[11] \"Ken Watanabe\"              \n\n\nLa descripción del grafo h1 confirma que hwd es un grafo bipartito. Los enlaces conectan a cada actor con las películas en las que participó. La red tiene 1,365 nodos y 1,600 vínculos, compuesta por 160 nodos de películas y 1,205 nodos de actores.\nCon el paquete igraph, es posible almacenar información de visualización dentro del objeto de la red, como colores y formas de los nodos, configurándolos como atributos de los vértices.\n\nV(h1)$shape &lt;-ifelse(V(h1)$type==TRUE,\n                     \"square\",\"circle\")\nV(h1)$shape[1:10]\n\n [1] \"square\" \"square\" \"square\" \"square\" \"square\" \"square\" \"square\" \"square\"\n [9] \"square\" \"square\"\n\nV(h1)$color &lt;-ifelse(V(h1)$type==TRUE,\n                     \"red\",\"lightblue\")\n\nExtraer relaciones que son incidentes a ciertos nodos en particular:\n\nset.seed(123)\nh2 &lt;- subgraph_from_edges(h1, E(h1)[.inc(V(h1)[name %in% c(\"The Wolf of Wall Street\", \"Gangs of New York\", \"The Departed\")])])\nplot(h2, layout = layout_with_kk)\n\n\n\n\n\n\n\n\nEstadísticas de la red\nDensidad de la red: No es muy relevante, ya que todos los actores están conectados a al menos una película y no existen conexiones directas entre actores o películas.\n\ngraph.density(h1)\n\n[1] 0.001718711\n\n\nGrado\n\ntable(igraph::degree(h1,v=V(h1)[type==FALSE]))\n\n\n  1   2   3   4   5   6   7   8 \n955 165  47  23  11   2   1   1 \n\nmean(igraph::degree(h1,v=V(h1)[type==FALSE]))\n\n[1] 1.327801\n\n\nLa mayoría de actores solo apareció en una película, pero 15 actores participaron en cinco o más desde 1999. En promedio, cada actor apareció en 1.3 películas.\nPopularidad\n\nV(h1)$deg &lt;- igraph::degree(h1)\nV(h1)[type==FALSE & deg &gt; 4]$name\n\n [1] \"Leonardo DiCaprio\" \"Emma Watson\"       \"Richard Griffiths\"\n [4] \"Harry Melling\"     \"Daniel Radcliffe\"  \"Rupert Grint\"     \n [7] \"James Franco\"      \"Ian McKellen\"      \"Martin Freeman\"   \n[10] \"Bradley Cooper\"    \"Christian Bale\"    \"Samuel L. Jackson\"\n[13] \"Natalie Portman\"   \"Brad Pitt\"         \"Liam Neeson\"      \n\nbusy_actor &lt;- data.frame(cbind(\n  Actor = V(h1)[type==FALSE & deg &gt; 4]$name,\n  Movies = V(h1)[type==FALSE & deg &gt; 4]$deg\n))\nbusy_actor[order(busy_actor$Movies,decreasing=TRUE),]\n\n               Actor Movies\n5   Daniel Radcliffe      8\n11    Christian Bale      7\n1  Leonardo DiCaprio      6\n2        Emma Watson      6\n3  Richard Griffiths      5\n4      Harry Melling      5\n6       Rupert Grint      5\n7       James Franco      5\n8       Ian McKellen      5\n9     Martin Freeman      5\n10    Bradley Cooper      5\n12 Samuel L. Jackson      5\n13   Natalie Portman      5\n14         Brad Pitt      5\n15       Liam Neeson      5\n\n\nPara medir la popularidad de los actores, se suma la calificación promedio de IMDb de las películas en las que actuaron.\n\nfor (i in 161:1365) {\n  V(h1)[i]$totrating &lt;- sum(V(h1)[.nei(i)]$IMDBrating)\n}\n\nmax(V(h1)$totrating,na.rm=TRUE)\n\n[1] 60.9\n\npop_actor &lt;- data.frame(cbind(\n  Actor = V(h1)[type==FALSE & totrating &gt; 40]$name,\n  Popularity = V(h1)[type==FALSE &\n                       totrating &gt; 40]$totrating))\npop_actor[order(pop_actor$Popularity,decreasing=TRUE),]\n\n              Actor Popularity\n3  Daniel Radcliffe       60.9\n4    Christian Bale       55.5\n1 Leonardo DiCaprio       49.6\n2       Emma Watson         45\n5         Brad Pitt       40.5\n\n\nRegresión\nSe examina si los actores más ocupados protagonizan películas más populares, a través de la media de calificaciones de IMDb y un análisis de regresión.\n\nfor (i in 161:1365) {\n  V(h1)[i]$avgrating &lt;- mean(V(h1)[.nei(i)]$IMDBrating)\n}\nnum &lt;- V(h1)[type==FALSE]$deg\navgpop &lt;- V(h1)[type==FALSE]$avgrating\nsummary(lm(avgpop ~ num))\n\n\nCall:\nlm(formula = avgpop ~ num)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-3.9858 -0.4330  0.1977  0.6170  1.6142 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)  7.33868    0.05440 134.911   &lt;2e-16 ***\nnum          0.04714    0.03527   1.337    0.182    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.9605 on 1203 degrees of freedom\nMultiple R-squared:  0.001483,  Adjusted R-squared:  0.0006528 \nF-statistic: 1.786 on 1 and 1203 DF,  p-value: 0.1816\n\nscatter.smooth(num,avgpop,col=\"lightblue\",\n               ylim=c(2,10),span=.8,\n               xlab=\"Number of Movies\",\n               ylab=\"Avg. Popularity\")\n\n\n\n\n\n\n\n\nEl resultado muestra que no hay una relación clara entre el número de películas y la popularidad.\nAnálisis de proyecciones de actores y de películas\nSe crean las dos redes: - Red de actores: Los actores están conectados si actuaron juntos en una película (1,205 nodos). - Red de películas: Las películas están conectadas si comparten actores (160 nodos).\n\nh1.pr &lt;-bipartite_projection(h1)\nh1.act &lt;-h1.pr$proj1\nh1.mov &lt;-h1.pr$proj2\nh1.act\n\nIGRAPH 61ec512 UNW- 1205 6903 -- \n+ attr: name (v/c), year (v/n), IMDBrating (v/n), MPAArating (v/c),\n| shape (v/c), color (v/c), deg (v/n), totrating (v/n), avgrating\n| (v/n), weight (e/n)\n+ edges from 61ec512 (vertex names):\n [1] Leonardo DiCaprio--Joseph Gordon-Levitt\n [2] Leonardo DiCaprio--Ellen Page          \n [3] Leonardo DiCaprio--Tom Hardy           \n [4] Leonardo DiCaprio--Ken Watanabe        \n [5] Leonardo DiCaprio--Dileep Rao          \n [6] Leonardo DiCaprio--Cillian Murphy      \n+ ... omitted several edges\n\nh1.mov\n\nIGRAPH 61ec567 UNW- 160 472 -- \n+ attr: name (v/c), year (v/n), IMDBrating (v/n), MPAArating (v/c),\n| shape (v/c), color (v/c), deg (v/n), totrating (v/n), avgrating\n| (v/n), weight (e/n)\n+ edges from 61ec567 (vertex names):\n [1] Inception--The Wolf of Wall Street    Inception--Django Unchained          \n [3] Inception--The Departed               Inception--Gangs of New York         \n [5] Inception--Catch Me If You Can        Inception--The Dark Knight Rises     \n [7] Inception--10 Things I Hate About You Inception--Batman Begins             \n [9] Inception--The Dark Knight            Inception--Training Day              \n[11] Inception--Big Fish                  \n+ ... omitted several edges\n\n\nEn la red de películas, el tamaño de los nodos representa la popularidad de las películas según su calificación en IMDb.\n\nop &lt;- par(mar = rep(0, 4))\nset.seed(123)\nplot(h1.mov,vertex.color=\"red\",\n     vertex.shape=\"circle\",\n     vertex.size=(V(h1.mov)$IMDBrating)-3,\n     vertex.label=NA)\n\n\n\n\n\n\n\npar(op)\n\nAlgunas estadísticas descriptivas de esta red son:\n\ngraph.density(h1.mov)\n\n[1] 0.03710692\n\ncount_components(h1.mov)\n\n[1] 12\n\nclusters(h1.mov)$csize\n\n [1] 148   1   1   1   1   1   1   2   1   1   1   1\n\ntable(E(h1.mov)$weight)\n\n\n  1   2   3   4   5   6   7  10 \n411  21  12  16   6   1   2   3 \n\n\nLa componente más grande de la red es:\n\nh2.mov &lt;- induced_subgraph(h1.mov, vids=clusters(h1.mov)$membership==1)\n\nplot(h2.mov,vertex.color=\"red\",\n     edge.width=sqrt(E(h1.mov)$weight),\n     vertex.shape=\"circle\",\n     vertex.size=(V(h2.mov)$IMDBrating)-3,\n     vertex.label=NA)\n\n\n\n\n\n\n\ntable(coreness(h2.mov))\n\n\n 1  2  3  4  5  6  7 \n11  5 23 65 29  7  8 \n\n\nRed con nodos más conectados, agregando labels a los nodos:\n\nh3.mov &lt;-induced_subgraph(h2.mov, vids=coreness(h2.mov)&gt;4)\nh3.mov\n\nIGRAPH 639d0d8 UNW- 44 158 -- \n+ attr: name (v/c), year (v/n), IMDBrating (v/n), MPAArating (v/c),\n| shape (v/c), color (v/c), deg (v/n), totrating (v/n), avgrating\n| (v/n), weight (e/n)\n+ edges from 639d0d8 (vertex names):\n[1] Alice in Wonderland                      --Hot Tub Time Machine               \n[2] Hot Tub Time Machine                     --The Interview                      \n[3] The Hobbit: The Battle of the Five Armies--The Hobbit: The Desolation of Smaug\n[4] Inception                                --The Wolf of Wall Street            \n[5] Exodus: Gods and Kings                   --American Hustle                    \n+ ... omitted several edges\n\nset.seed(123)\nplot(h3.mov,vertex.color=\"red\",\n     vertex.shape=\"circle\",\n     edge.width=sqrt(E(h1.mov)$weight),\n     vertex.label.cex=0.7,vertex.label.color=\"darkgreen\",\n     vertex.label.dist=0.3,\n     vertex.size=(V(h3.mov)$IMDBrating)-3)",
    "crumbs": [
      "Talleres",
      "Taller 2"
    ]
  }
]